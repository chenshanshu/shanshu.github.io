{"meta":{"title":"MyBlog","subtitle":"","description":"前端开发 javascript css html 样式","author":"chenss","url":"https://chenshanshu.github.io/2020/06/15/hello-world","root":"/"},"pages":[{"title":"","date":"2025-02-07T05:41:57.762Z","updated":"2025-02-07T05:41:57.762Z","comments":true,"path":"about/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-10T10:31:12.000Z","updated":"2025-02-07T05:41:57.762Z","comments":true,"path":"categories/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-02-07T05:41:57.762Z","updated":"2025-02-07T05:41:57.762Z","comments":true,"path":"examples/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/examples/index.html","excerpt":"","text":"democanvas 文件名 链接 图片裁剪1 地址 图片裁剪2 地址 捉小猫 地址 飞机大战 地址 数字游戏 地址"},{"title":"tags","date":"2022-01-10T10:31:55.000Z","updated":"2025-02-07T05:41:57.828Z","comments":true,"path":"tags/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/index.html","excerpt":"","text":""},{"title":"mylist","date":"2025-02-07T05:41:57.828Z","updated":"2025-02-07T05:41:57.828Z","comments":true,"path":"mylist/index.html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"next.js项目开发遇到的问题","slug":"next-js项目开发遇到的问题","date":"2025-02-07T10:56:55.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2025/02/07/next-js项目开发遇到的问题/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2025/02/07/next-js%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"项目启动后，初始渲染内容为空，页面元素全部是 js 插入的项目开发接近尾声，发现 ssr 不能正常渲染，发现所有的Server Components能正常ssr，而所有的Client Components不正常。这里介绍下这两种组件： What do you need to do? Server Component Client Component Fetch data Access backend resources (directly) Keep sensitive information on the server (access tokens, API keys, etc) Keep large dependencies on the server / Reduce client-side JavaScript Add interactivity and event listeners (onClick(), onChange(), etc) Use State and Lifecycle Effects (useState(), useReducer(), useEffect(), etc) Use browser-only APIs Use custom hooks that depend on state, effects, or browser-only APIs Use React Class components 调查陷入误区以为Client Components导致的问题。然后就查看demo，一点点注释代码找到了下面两个问题。","text":"项目启动后，初始渲染内容为空，页面元素全部是 js 插入的项目开发接近尾声，发现 ssr 不能正常渲染，发现所有的Server Components能正常ssr，而所有的Client Components不正常。这里介绍下这两种组件： What do you need to do? Server Component Client Component Fetch data Access backend resources (directly) Keep sensitive information on the server (access tokens, API keys, etc) Keep large dependencies on the server / Reduce client-side JavaScript Add interactivity and event listeners (onClick(), onChange(), etc) Use State and Lifecycle Effects (useState(), useReducer(), useEffect(), etc) Use browser-only APIs Use custom hooks that depend on state, effects, or browser-only APIs Use React Class components 调查陷入误区以为Client Components导致的问题。然后就查看demo，一点点注释代码找到了下面两个问题。 在 Next.js 中使用 Redux Persist 会影响服务端渲染解决方案：动态加载 PersistGate 1234567891011121314151617181920212223&quot;use client&quot;;import &#123; useState, useEffect &#125; from &quot;react&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import &#123; PersistGate &#125; from &quot;redux-persist/integration/react&quot;;import &#123; originStore, store, persistor &#125; from &quot;@/store/store&quot;;export default function Layout(&#123; children &#125;) &#123; const [mounted, setMounted] = useState(false); useEffect(() =&gt; &#123; setMounted(true); &#125;, []); if (!mounted) &#123; return &lt;Provider store=&#123;originStore&#125;&gt;&#123;children&#125;&lt;/Provider&gt;; &#125; else &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;PersistGate loading=&#123;null&#125; persistor=&#123;persistor&#125;&gt; &#123;children&#125; &lt;/PersistGate&gt; &lt;/Provider&gt; ); &#125;&#125; Suspense 也会影响服务端渲染1234567891011121314151617181920212223242526272829import &#123; Suspense &#125; from &quot;react&quot;;import Loading from &quot;./Loading&quot;;// Suspense 的多种使用场景export default function Dashboard() &#123; return ( &lt;div&gt; &#123;/* 1. 处理异步数据加载 */&#125; &lt;Suspense fallback=&#123;&lt;UserProfileSkeleton /&gt;&#125;&gt; &lt;UserProfile /&gt; &lt;/Suspense&gt; &#123;/* 2. 代码分割 */&#125; &lt;Suspense fallback=&#123;&lt;ChartSkeleton /&gt;&#125;&gt; &lt;LazyLoadedChart /&gt; &lt;/Suspense&gt; &#123;/* 3. 并行加载多个异步组件 */&#125; &lt;div className=&quot;grid&quot;&gt; &lt;Suspense fallback=&#123;&lt;RecentPostsSkeleton /&gt;&#125;&gt; &lt;RecentPosts /&gt; &lt;/Suspense&gt; &lt;Suspense fallback=&#123;&lt;UserActivitySkeleton /&gt;&#125;&gt; &lt;UserActivity /&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/div&gt; );&#125; Suspense 的工作原理 123456789101112131415161718// Suspense 如何工作的简化示例function Suspense(&#123; fallback, children &#125;) &#123; try &#123; // 尝试渲染子组件 const result = renderChildren(children); // 如果子组件准备就绪，直接渲染 return result; &#125; catch (promise) &#123; // 如果子组件还在加载，渲染 fallback if (promise instanceof Promise) &#123; return fallback; &#125; // 处理其他错误 throw promise; &#125;&#125; Suspense 的关键特性： - 处理异步渲染 - 提供加载状态管理 - 实现代码分割 - 改善用户体验 - 支持服务端和客户端组件 项目引入的第三方包里面有对window或者浏览器api的引用这里以Yuan为例子，这个包import进来就会报错 使用dynamic引入123456import dynamic from &#x27;next/dynamic&#x27;// 动态导入组件const Yuan = dynamic(() =&gt; import(&#x27;Yuan&#x27;), &#123; loading: () =&gt; &lt;p&gt;Loading...&lt;/p&gt;, ssr: false // 可选：仅客户端渲染&#125;) 这样开发和浏览器控制台没有报错，页面也能展示，但是ssr返回的标签里会插入一个错误信息。 123456789&#x27;use client&#x27;export default function(props)&#123; if(typeof window === &#x27;undefined&#x27;)&#123; return null; &#125;else&#123; const Yuan = require(&#x27;pingansec-vue-yuan&#x27;).default return new Yuan(props); &#125;&#125;","categories":[],"tags":[{"name":"react next.js","slug":"react-next-js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/react-next-js/"}]},{"title":"获取一个长列表当前滑动的位置","slug":"获取一个长列表当前滑动的位置","date":"2024-07-24T11:19:36.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2024/07/24/获取一个长列表当前滑动的位置/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2024/07/24/%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E9%95%BF%E5%88%97%E8%A1%A8%E5%BD%93%E5%89%8D%E6%BB%91%E5%8A%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"question: 在一个列表页中，每个子元素高度不固定，怎么获取到当前视窗中的元素是第几个 使用 elementFromPoint elementFromPoint 方法可以根据指定的坐标点，返回与该点最近的元素。如果指定坐标上没有元素，则返回 null 1const element = document.elementFromPoint(x, y); 具体实现 1234567891011121314151617181920212223242526// 递增 x，y 坐标，直到找到包含目标类名的元素为止function getElement(className) &#123; let x = 0; let y = 0; while (!element &amp;&amp; y &lt; window.innerHeight) &#123; x++; y++; element = document.elementFromPoint(x, y); if (!element.className.includes(className)) &#123; element = null; &#125; &#125;&#125;// 获取元素的索引function getElementIndex(element) &#123; if (element &amp;&amp; element.parentNode) &#123; var children = element.parentNode.children; for (var i = 0; i &lt; children.length; i++) &#123; if (children[i] === element) &#123; return i; &#125; &#125; &#125; return 0;&#125; 使用 scrollTop scrollTop 属性返回或设置元素的垂直滚动位置。 1const scrollTop = element.scrollTop; 循环元素，然后累加高度直至高度超过 scrollTop，此时的 i 就是元素的索引 123456789function getElementIndex(element) &#123; let i = 0; let height = 0; while (height &lt; element.scrollTop) &#123; i++; height += element.children[i].offsetHeight; &#125; return i;&#125; getBoundingClientRect getBoundingClientRect 方法返回元素的大小及其相对于视口的位置。 1const rect = element.getBoundingClientRect(); 监听滚动事件，然后遍历元素计算其位置，直到发现 top 大于 0 的第一个元素，此时的 i 就是元素的索引 123456789function getElementIndex(element) &#123; let i = 0; let rect = element.getBoundingClientRect(); while (rect.top &lt; 0) &#123; i++; rect = element.children[i].getBoundingClientRect(); &#125; return i;&#125; IntersectionObserver IntersectionObserver 接口可以用来监测元素与祖先元素或顶级文档视窗（viewport）交叉状态的变化。 1234567891011121314151617const observer = new IntersectionObserver(callback, options);````具体实现```jsfunction getElementIndex(element) &#123; const observer = new IntersectionObserver((entries) =&gt; &#123; entries.forEach((entry) =&gt; &#123; if (entry.isIntersecting) &#123; observer.unobserve(element); return entry.target; &#125; &#125;); &#125;); observer.observe(element);&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"css绘制一个斜条纹进度条","slug":"css绘制一个斜条纹进度条","date":"2024-07-18T20:53:15.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2024/07/18/css绘制一个斜条纹进度条/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2024/07/18/css%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%9C%E6%9D%A1%E7%BA%B9%E8%BF%9B%E5%BA%A6%E6%9D%A1/","excerpt":"123&lt;div class=&quot;progress-row&quot;&gt; &lt;div class=&quot;progress-bar&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940.progress-row &#123; width: 100px; height: 10px; border-radius: 5px; background-color: #eff6fb; overflow: hidden;&#125;.progress-bar &#123; height: 100%; background-color: #327bf9; /* background: linear-gradient( 45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0 ); */ background-image: linear-gradient( 45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 0 ); animation: slide 1s linear infinite; background-size: 12px 12px; transition: width 1s;&#125;@keyframes slide &#123; 0% &#123; background-position-x: 0px; &#125; 100% &#123; background-position-x: 12px; &#125;&#125;","text":"123&lt;div class=&quot;progress-row&quot;&gt; &lt;div class=&quot;progress-bar&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940.progress-row &#123; width: 100px; height: 10px; border-radius: 5px; background-color: #eff6fb; overflow: hidden;&#125;.progress-bar &#123; height: 100%; background-color: #327bf9; /* background: linear-gradient( 45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0 ); */ background-image: linear-gradient( 45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 0 ); animation: slide 1s linear infinite; background-size: 12px 12px; transition: width 1s;&#125;@keyframes slide &#123; 0% &#123; background-position-x: 0px; &#125; 100% &#123; background-position-x: 12px; &#125;&#125; .example-box{ width:100%; min-height:100px; border-radius:10px; border:1px solid #efefef; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .progress-row { width: 100px; height: 10px; border-radius: 5px; background-color: #eff6fb; overflow: hidden; } .progress-bar { height: 100%; background-color: #327bf9; /* background: linear-gradient( 45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0 ); */ background-image: linear-gradient( 45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 0 ); animation: slide 1s linear infinite; background-size: 12px 12px; transition: width 1s; } @keyframes slide { 0% { background-position-x: 0px; } 100% { background-position-x: 12px; } }","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/css/"}]},{"title":"除了keep-alive还有哪些页面缓存方案","slug":"除了keep-alive还有哪些页面缓存方案","date":"2024-05-09T16:08:31.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2024/05/09/除了keep-alive还有哪些页面缓存方案/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2024/05/09/%E9%99%A4%E4%BA%86keep-alive%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/","excerpt":"引言有这么一个需求：列表页进入详情页后，切换回列表页，需要对列表页进行缓存，如果从首页进入列表页，就要重新加载列表页。对于这个需求，我的第一个想法就是使用keep-alive来缓存列表页，列表和详情页切换时，列表页会被缓存；从首页进入列表页时，就重置列表页数据并重新获取新数据来达到列表页重新加载的效果。但是，这个方案有个很不好的地方就是：如果列表页足够复杂，有下拉刷新、下拉加载、有弹窗、有轮播等，在清除缓存时，就需要重置很多数据和状态，而且还可能要手动去销毁和重新加载某些组件，这样做既增加了复杂度，也容易出bug。接下来说说我的想到的新实现方案（代码基于Vue3）。","text":"引言有这么一个需求：列表页进入详情页后，切换回列表页，需要对列表页进行缓存，如果从首页进入列表页，就要重新加载列表页。对于这个需求，我的第一个想法就是使用keep-alive来缓存列表页，列表和详情页切换时，列表页会被缓存；从首页进入列表页时，就重置列表页数据并重新获取新数据来达到列表页重新加载的效果。但是，这个方案有个很不好的地方就是：如果列表页足够复杂，有下拉刷新、下拉加载、有弹窗、有轮播等，在清除缓存时，就需要重置很多数据和状态，而且还可能要手动去销毁和重新加载某些组件，这样做既增加了复杂度，也容易出bug。接下来说说我的想到的新实现方案（代码基于Vue3）。 keep-alive 缓存和清除 keep-alive 缓存原理：进入页面时，页面组件渲染完成，keep-alive 会缓存页面组件的实例；离开页面后，组件实例由于已经缓存就不会进行销毁；当再次进入页面时，就会将缓存的组件实例拿出来渲染，因为组件实例保存着原来页面的数据和Dom的状态，那么直接渲染组件实例就能得到原来的页面。 keep-alive 最大的难题就是缓存的清理，如果能有简单的缓存清理方法，那么keep-alive 组件用起来就很爽。但是，keep-alive 组件没有提供清除缓存的API，那有没有其他清除缓存的办法呢？答案是有的。我们先看看 keep-alive 组件的props： 123include - string | RegExp | Array。只有名称匹配的组件会被缓存。exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存。max - number | string。最多可以缓存多少组件实例。 从include描述来看，我发现include是可以用来清除缓存，做法是：将组件名称添加到include里，组件会被缓存；移除组件名称，组件缓存会被清除。根据这个原理，用hook简单封装一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; ref, nextTick &#125; from &#x27;vue&#x27;const caches = ref&lt;string[]&gt;([])export default function useRouteCache () &#123; // 添加缓存的路由组件 function addCache (componentName: string | string []) &#123; if (Array.isArray(componentName)) &#123; componentName.forEach(addCache) return &#125; if (!componentName || caches.value.includes(componentName)) return caches.value.push(componentName) &#125; // 移除缓存的路由组件 function removeCache (componentName: string) &#123; const index = caches.value.indexOf(componentName) if (index &gt; -1) &#123; return caches.value.splice(index, 1) &#125; &#125; // 移除缓存的路由组件的实例 async function removeCacheEntry (componentName: string) &#123; if (removeCache(componentName)) &#123; await nextTick() addCache(componentName) &#125; &#125; return &#123; caches, addCache, removeCache, removeCacheEntry &#125;&#125; hook的用法如下： 12345678910111213&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt; &lt;keep-alive :include=&quot;caches&quot;&gt; &lt;component :is=&quot;Component&quot; /&gt; &lt;/keep-alive&gt;&lt;/router-view&gt;&lt;script setup lang=&quot;ts&quot;&gt;import useRouteCache from &#x27;./hooks/useRouteCache&#x27;const &#123; caches, addCache &#125; = useRouteCache()&lt;!-- 将列表页组件名称添加到需要缓存名单中 --&gt;addCache([&#x27;List&#x27;])&lt;/script&gt; 清除列表页缓存如下： 12345import useRouteCache from &#x27;@/hooks/useRouteCache&#x27;const &#123; removeCacheEntry &#125; = useRouteCache()removeCacheEntry(&#x27;List&#x27;) 此处removeCacheEntry方法清除的是列表组件的实例，’List’ 值仍然在 组件的include里，下次重新进入列表页会重新加载列表组件，并且之后会继续列表组件进行缓存。 列表页清除缓存的时机进入列表页后清除缓存在列表页路由组件的beforeRouteEnter勾子中判断是否是从其他页面（Home）进入的，是则清除缓存，不是则使用缓存。 123456789defineOptions(&#123; name: &#x27;List1&#x27;, beforeRouteEnter (to: RouteRecordNormalized, from: RouteRecordNormalized) &#123; if (from.name === &#x27;Home&#x27;) &#123; const &#123; removeCacheEntry &#125; = useRouteCache() removeCacheEntry(&#x27;List1&#x27;) &#125; &#125;&#125;) 这种缓存方式有个不太友好的地方：当从首页进入列表页，列表页和详情页来回切换，列表页是缓存的；但是在首页和列表页间用浏览器的前进后退来切换时，我们更多的是希望列表页能保留缓存，就像在多页面中浏览器前进后退会缓存原页面一样的效果。但实际上，列表页重新刷新了，这就需要使用另一种解决办法，点击链接时清除缓存清除缓存。 点击链接跳转前清除缓存在首页点击跳转列表页前，在点击事件的时候去清除列表页缓存，这样的话在首页和列表页用浏览器的前进后退来回切换，列表页都是缓存状态，只要当重新点击跳转链接的时候，才重新加载列表页，满足预期。 123456789101112131415161718192021// 首页 Home.vue&lt;li&gt; &lt;router-link to=&quot;/list&quot; @click=&quot;removeCacheBeforeEnter&quot;&gt;列表页&lt;/router-link&gt;&lt;/li&gt;&lt;script setup lang=&quot;ts&quot;&gt;import useRouteCache from &#x27;@/hooks/useRouteCache&#x27;defineOptions(&#123; name: &#x27;Home&#x27;&#125;)const &#123; removeCacheEntry &#125; = useRouteCache()// 进入页面前，先清除缓存实例function removeCacheBeforeEnter () &#123; removeCacheEntry(&#x27;List&#x27;)&#125;&lt;/script&gt; 状态管理实现缓存通过状态管理库存储页面的状态和数据也能实现页面缓存。此处状态管理使用的是pinia。首先使用pinia创建列表页store： 1234567891011121314151617181920212223242526272829303132import &#123; defineStore &#125; from &#x27;pinia&#x27;interface Item &#123; id?: number, content?: string&#125;const useListStore = defineStore(&#x27;list&#x27;, &#123; // 推荐使用 完整类型推断的箭头函数 state: () =&gt; &#123; return &#123; isRefresh: true, pageSize: 30, currentPage: 1, list: [] as Item[], curRow: null as Item | null &#125; &#125;, actions: &#123; setList (data: Item []) &#123; this.list = data &#125;, setCurRow (data: Item) &#123; this.curRow = data &#125;, setIsRefresh (data: boolean) &#123; this.isRefresh = data &#125; &#125;&#125;)export default useListStore 通过beforeRouteEnter钩子判断是否从首页进来，是则通过 listStore.$reset() 来重置数据，否则使用缓存的数据状态；之后根据 listStore.isRefresh 标示判断是否重新获取列表数据。 12345678910111213141516171819defineOptions(&#123; beforeRouteEnter (to: RouteLocationNormalized, from: RouteLocationNormalized) &#123; if (from.name === &#x27;Home&#x27;) &#123; const listStore = useListStore() listStore.$reset() &#125; &#125;&#125;)onBeforeMount(() =&gt; &#123; if (!listStore.useCache) &#123; loading.value = true setTimeout(() =&gt; &#123; listStore.setList(getData()) loading.value = false &#125;, 1000) listStore.useCache = true &#125;&#125;) 缺点通过状态管理去做缓存的话，需要将状态数据都存在stroe里，状态多起来的话，会有点繁琐，而且状态写在store里肯定没有写在列表组件里来的直观；状态管理由于只做列表页数据的缓存，对于一些非受控组件来说，组件内部状态改变是缓存不了的，这就导致页面渲染后跟原来有差别，需要额外代码操作。 页面弹窗实现缓存将详情页做成全屏弹窗，那么从列表页进入详情页，就只是简单地打开详情页弹窗，将列表页覆盖，从而达到列表页 “缓存”的效果，而非真正的缓存。这里还有一个问题，打开详情页之后，如果点后退，会返回到首页，实际上我们希望是返回列表页，这就需要给详情弹窗加个历史记录，如列表页地址为 ‘/list’，打开详情页变为 ‘/list?id=1’。弹窗组件实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// PopupPage.vue&lt;template&gt; &lt;div class=&quot;popup-page&quot; :class=&quot;[!dialogVisible &amp;&amp; &#x27;hidden&#x27;]&quot;&gt; &lt;slot v-if=&quot;dialogVisible&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useLockscreen &#125; from &#x27;element-plus&#x27;import &#123; computed, defineProps, defineEmits &#125; from &#x27;vue&#x27;import useHistoryPopup from &#x27;./useHistoryPopup&#x27;const props = defineProps(&#123; modelValue: &#123; type: Boolean, default: false &#125;, // 路由记录 history: &#123; type: Object &#125;, // 配置了history后，初次渲染时，如果有url上有history参数，则自动打开弹窗 auto: &#123; type: Boolean, default: true &#125;, size: &#123; type: String, default: &#x27;50%&#x27; &#125;, full: &#123; type: Boolean, default: false &#125;&#125;)const emit = defineEmits( [&#x27;update:modelValue&#x27;, &#x27;autoOpen&#x27;, &#x27;autoClose&#x27;])const dialogVisible = computed&lt;boolean&gt;(&#123; // 控制弹窗显示 get () &#123; return props.modelValue &#125;, set (val) &#123; emit(&#x27;update:modelValue&#x27;, val) &#125;&#125;)useLockscreen(dialogVisible)useHistoryPopup(&#123; history: computed(() =&gt; props.history), auto: props.auto, dialogVisible: dialogVisible, onAutoOpen: () =&gt; emit(&#x27;autoOpen&#x27;), onAutoClose: () =&gt; emit(&#x27;autoClose&#x27;)&#125;)&lt;/script&gt;&lt;style lang=&#x27;less&#x27;&gt;.popup-page &#123; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 100; overflow: auto; padding: 10px; background: #fff; &amp;.hidden &#123; display: none; &#125;&#125;&lt;/style&gt; 缺点弹窗实现页面缓存，局限比较大，只能在列表页和详情页中才有效，离开列表页之后，缓存就会失效，比较合适一些简单缓存的场景。 父子路由实现缓存该方案原理其实就是页面弹窗，列表页为父路由，详情页为子路由，从列表页跳转到详情页时，显示详情页字路由，且详情页全屏显示，覆盖住列表页。声明父子路由: 123456789101112&#123; path: &#x27;/list&#x27;, name: &#x27;list&#x27;, component: () =&gt; import(&#x27;./views/List.vue&#x27;), children: [ &#123; path: &#x27;/detail&#x27;, name: &#x27;detail&#x27;, component: () =&gt; import(&#x27;./views/Detail.vue&#x27;), &#125; ]&#125; 列表页代码: 1234567891011121314151617181920212223242526272829303132333435// 列表页&lt;template&gt; &lt;el-table v-loading=&quot;loading&quot; :data=&quot;tableData&quot; border style=&quot;width: 100%; margin-top: 30px;&quot;&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;id&quot; /&gt; &lt;el-table-column prop=&quot;content&quot; label=&quot;内容&quot;/&gt; &lt;el-table-column label=&quot;操作&quot;&gt; &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt; &lt;el-link type=&quot;primary&quot; @click=&quot;gotoDetail(row)&quot;&gt;进入详情&lt;/el-link&gt; &lt;el-tag type=&quot;success&quot; v-if=&quot;row.id === curRow?.id&quot;&gt;刚点击&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination v-model:currentPage=&quot;currentPage&quot; :page-size=&quot;pageSize&quot; layout=&quot;total, prev, pager, next&quot; :total=&quot;list.length&quot; /&gt; &lt;!-- 详情页 --&gt; &lt;router-view class=&quot;popyp-page&quot;&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;style lang=&#x27;less&#x27; scoped&gt;.popyp-page &#123; position: fixed; top: 0; bottom: 0; left: 0; right: 0; z-index: 100; background: #fff; overflow: auto;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue/"}]},{"title":"flex布局","slug":"flex布局","date":"2024-03-25T13:56:21.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2024/03/25/flex布局/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2024/03/25/flex%E5%B8%83%E5%B1%80/","excerpt":".father{ border:1px solid; margin-bottom: 10px; } .child{ width: 200px; height: 80px; line-height: 80px; text-align: center; background: #efefef; border:1px solid #ccc; } 12345&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 弹性盒子布局 flex123.father&#123; display: flex;&#125; child1 child2 child3","text":".father{ border:1px solid; margin-bottom: 10px; } .child{ width: 200px; height: 80px; line-height: 80px; text-align: center; background: #efefef; border:1px solid #ccc; } 12345&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 弹性盒子布局 flex123.father&#123; display: flex;&#125; child1 child2 child3 元素间距 gap1234.father&#123; display: flex; gap: 10px;&#125; child1 child2 child3 排列方向12345.father&#123; display: flex; gap: 10px; flex-flow: row nowrap; &#125; 横向 超出不换行 （默认）flex-flow: row nowrap; 当子元素宽度超过父元素，子元素宽度会被压缩。 child1 child2 child3 child4 child5 child6 横向 超出换行 flex-flow: row wrap; child1 child2 child3 child4 child5 child6 child7 child8 竖向 超出不换行 flex-flow: column nowrap; child1 child2 child3 竖向 超出换行 flex-flow: column wrap;（不太常用，间隔怪异） child1 child2 child3 child4 child5 child6 对齐方式1234.father&#123; display: flex; justify-content: flex-start;&#125; 左对齐（默认） justify-content: flex-start; child1 child2 child3 右对齐 justify-content: flex-end; child1 child2 child3 中对齐 justify-content: center; child1 child2 child3 两侧靠边剩余空间平分 justify-content: space-between; child1 child2 child3 每个子元素左右各分一部分 justify-content: space-around; child1 child2 child3 交叉轴的对齐1234.father&#123; display: flex; align-items: flex-start;&#125; 上对齐（默认） align-items: flex-start; child1 child2 child3 中对齐 align-items: center; child1 child2 child3 下对齐 align-items: flex-end; child1 child2 child3 居中12345.father&#123; display: flex; justify-content: center; align-items: center;&#125; child1","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/css/"}]},{"title":"react-ssr的实现","slug":"react-ssr的实现","date":"2024-02-01T09:58:09.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2024/02/01/react-ssr的实现/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2024/02/01/react-ssr%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"浏览器解析过程从输入URL到页面渲染完成大致流程为： 解析URL 浏览器本地缓存 DNS解析 建立TCP/IP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器根据深度遍历的方式把html节点遍历构建DOM树 遇到CSS外链，异步加载解析CSS,构建CSS规则树 遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer/async属性则异步加载JS资源 将dom树和CSS DOM树构造成render树 渲染render树","text":"浏览器解析过程从输入URL到页面渲染完成大致流程为： 解析URL 浏览器本地缓存 DNS解析 建立TCP/IP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器根据深度遍历的方式把html节点遍历构建DOM树 遇到CSS外链，异步加载解析CSS,构建CSS规则树 遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer/async属性则异步加载JS资源 将dom树和CSS DOM树构造成render树 渲染render树 一.主流渲染方式1.1 CSR客户端渲染1.1.1 概念客户端渲染，指页面上的内容由浏览器执行js脚本而生成React SPA单页面应用项目就是客户端渲染 1.1.2 流程浏览器请求HTML,React项目利用webpack将页面打包成bundle.js脚本,插入index.html,浏览器请求到静态页面,会解析其中的bundle.js脚本,获取页面的动态数据和交互事件,向静态页面插入数据,最终形成完整的页面 1.1.3 优缺点优点 前后端分离,前端负责渲染页面,后端负责实现接口 前端跳转时,不需要请求后台,页面跳转更快 缺点 搜索引擎无法爬取分析网页内容,不利于SEO 需要等待整个应用的js加载以及数据请求获取网页动态数据,首屏加载时间长 1.2 SSR服务端渲染1.2.1 概念SSR服务端渲染(Server-side Rendering),指在浏览器发起页面请求后由服务端完成页面的HTML结构拼接。 1.2.2 流程将组件在服务端转化为HTML字符串，直接将其发送给浏览器，然后将其中静态标记”激活“为客户端上完全可交互的应用程序 1.2.3 优缺点优点 服务端直接输出HTML，SEO友好 加载首页无需加载整个应用的JS，首页加载速度快 缺点 页面每次跳转都要访问服务器，体验比客户端渲染差 二.服务端渲染实现要是实现一个完整的React-SSR渲染，要做的事如下 服务端执行React代码，生成HTML页面，并将打包好的客户端js文件插入HTML页面中 发送HTML页面至浏览器展示 浏览器加载HTML页面中的js文件 js代码执行，并绑定DOM事件，最后接管页面操作 【负责】 客户端：事件绑定、路由跳转 服务端：请求数据、绑定动态数据、渲染生成HTML 三.React项目服务端渲染 renderToString是react-dom/server提供的服务端渲染方法renderToString、renderToStaticMarkup、renderToNodeStream、renderToStaticNodeStream四个方法能够将React组件渲染成静态的HTML标签，前两个方法能在客户端和服务端运行，后两个只能在服务端运行 3.1 实现一个React组件的服务端渲染12345678910111213141516171819import express frm &#x27;express&#x27;;import &#123;renderToString&#125; from &#x27;react-dom/server&#x27;;import App from &#x27;./client/App&#x27;;const app = express();const content = renderToString(&lt;App /&gt;)app.get(&#x27;/&#x27;,function(req,res)&#123; res.send( `&lt;html&gt; &lt;head&gt;&lt;title&gt;ssr&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;$&#123;content&#125;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;` )&#125;)app.listen(3000,()=&gt;&#123; console.log(&#x27;listen:3000&#x27;)&#125;) 3.2实现同构渲染实现以下两步: 服务端可运行React代码 浏览器同样可运行React代码 两者共用一套React代码进行运行","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/react/"},{"name":"ssr","slug":"ssr","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/ssr/"}]},{"title":"身份证号脱敏","slug":"身份证号脱敏","date":"2023-12-12T16:26:49.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/12/12/身份证号脱敏/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/12/12/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E8%84%B1%E6%95%8F/","excerpt":"非前后端分离项目 .question-box{ background:#B7F4EC; color:#16004D; padding:12px 10px; font-weight:500; user-select:none; border-radius:6px; } .test-btn{ width: 80px; text-align: center; padding: 4px 10px; border-radius: 6px; background: #4CD263; color: #ffffff; cursor: pointer; margin-left: auto; user-select:none; } .test-btn:hover{ background: #7BE188; } .disable{ background: #86909c; cursor: default; } .disable:hover{ background: #86909c; } .text-box{ background: #efefef; border-radius: 6px; padding:12px 10px; } 需求：找到网页上的身份证号并脱敏 12345&lt;div&gt;321682199712237978&lt;div&gt;&lt;div&gt;这是一段文字用来测试321682199712237978身份证号码&lt;/div&gt;&lt;div&gt; 标签测试&lt;span&gt;321682&lt;em&gt;19971223&lt;/em&gt;7978&lt;/span&gt;&lt;/div&gt; 身份证号的正则 身份证开头两位是省级地址校验：华北：北京11，天津12，河北13，山西14，内蒙古15东北： 辽宁21，吉林22，黑龙江23华东： 上海31，江苏32，浙江33，安徽34，福建35，江西36，山东37华中： 河南41，湖北42，湖南43华南： 广东44，广西45，海南46西南： 四川51，贵州52，云南53，西藏54，重庆50西北： 陕西61，甘肃62，青海63，宁夏64，新疆65特别：台湾71，香港81，澳门82 年份校验：(18|19|20)\\d{2} 日期校验：((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31) 1/^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d&#123;4&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/","text":"非前后端分离项目 .question-box{ background:#B7F4EC; color:#16004D; padding:12px 10px; font-weight:500; user-select:none; border-radius:6px; } .test-btn{ width: 80px; text-align: center; padding: 4px 10px; border-radius: 6px; background: #4CD263; color: #ffffff; cursor: pointer; margin-left: auto; user-select:none; } .test-btn:hover{ background: #7BE188; } .disable{ background: #86909c; cursor: default; } .disable:hover{ background: #86909c; } .text-box{ background: #efefef; border-radius: 6px; padding:12px 10px; } 需求：找到网页上的身份证号并脱敏 12345&lt;div&gt;321682199712237978&lt;div&gt;&lt;div&gt;这是一段文字用来测试321682199712237978身份证号码&lt;/div&gt;&lt;div&gt; 标签测试&lt;span&gt;321682&lt;em&gt;19971223&lt;/em&gt;7978&lt;/span&gt;&lt;/div&gt; 身份证号的正则 身份证开头两位是省级地址校验：华北：北京11，天津12，河北13，山西14，内蒙古15东北： 辽宁21，吉林22，黑龙江23华东： 上海31，江苏32，浙江33，安徽34，福建35，江西36，山东37华中： 河南41，湖北42，湖南43华南： 广东44，广西45，海南46西南： 四川51，贵州52，云南53，西藏54，重庆50西北： 陕西61，甘肃62，青海63，宁夏64，新疆65特别：台湾71，香港81，澳门82 年份校验：(18|19|20)\\d{2} 日期校验：((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31) 1/^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d&#123;4&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/ 怎么去遍历dom树 document.getElementsByTagName(‘*’);获取所有标签元素,可以直接forEach循环 使用递归 12345678910111213loop(document);function loop(node)&#123; var nodes = node.childNodes; for (var i = 0; i &lt;nodes.length; i++)&#123; if(!nodes[i])&#123; continue; &#125; if(nodes[i].childNodes.length &gt; 0)&#123; loop(nodes[i]); &#125; &#125;&#125; 使用document.createNodeIterator 怎么判断过滤完成 获取全文的文本：document.body.innerText 通过正则全文匹配 正则表达式分组命名 我们用正则做局部替换时，常常用到$1,$2…，这些变量是匹配到的分组内容，当正则分组复杂时使用分组命名 (?&lt;自定义组名&gt;匹配的规则) 页面局部刷新后，怎么触发重新匹配1.使用api：MutationObserver 具体实现1234567891011121314151617181920212223242526272829303132333435363738394041function filterIdNO() &#123; try &#123; var Reg1 = /(?&lt;first&gt;((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d&#123;4&#125;)((?&lt;year&gt;(18|19|20)\\d&#123;2&#125;)((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31))(?&lt;last&gt;\\d&#123;3&#125;[0-9Xx])/g; var Reg2 = /^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d&#123;4&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/; function recursionDom(parent) &#123; var value = (parent.innerText || parent.textContent || &#x27;&#x27;).replace(/\\n/g, &#x27;&#x27;); if (!value.match(Reg1)) return var t = document.createNodeIterator(parent, NodeFilter.SHOW_TEXT, null, false) var currNode = null var mached = null while ((currNode = t.nextNode()) !== null) &#123; mached = Reg1.exec(currNode.textContent) if (Reg1.test(currNode.textContent)) &#123; currNode.textContent = currNode.textContent.replace(Reg1, function(m)&#123; return m.slice(0,6)+&#x27;********&#x27;+m.slice(-4) &#125;) &#125; &#125; value = (parent.innerText || parent.textContent || &#x27;&#x27;).replace(/\\n/g, &#x27;&#x27;); if (!value.match(Reg1)) return t = document.createNodeIterator(parent, NodeFilter.SHOW_ELEMENT, null, false) while ((currNode = t.nextNode()) !== null) &#123; if (Reg2.test(currNode.innerText)) &#123; // 从body开始匹配，不用严格会整个替换 currNode.innerText = currNode.innerText.replace(Reg1, function(m)&#123; return m.slice(0,6)+&#x27;********&#x27;+m.slice(-4) &#125;) &#125; &#125; &#125; recursionDom(document.body) var observer = new MutationObserver(function (mutatinRecords) &#123; // console.log(&#x27;mutatinRecords&#x27;, mutatinRecords) mutatinRecords.forEach(function (item) &#123; recursionDom(item.target) &#125;) &#125;) observer.observe(document.body, &#123; childList: true, characterData: true, subtree: true &#125;) &#125; catch (error) &#123; console.log(&#x27;catch&#x27;, error) &#125;&#125; 示例 321682199712237978 这是一段文字用来测试321682199712237978身份证号码 321682199712237978 测试一下 function filterIdNO() { try { var Reg1 = /(?((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d{4})((?(18|19|20)\\d{2})((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31))(?\\d{3}[0-9Xx])/g; var Reg2 = /^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d{4}(18|19|20)\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/; function recursionDom(parent) { var value = (parent.innerText || parent.textContent || '').replace(/\\n/g, ''); if (!value.match(Reg1)) return var t = document.createNodeIterator(parent, NodeFilter.SHOW_TEXT, null, false) var currNode = null var mached = null while ((currNode = t.nextNode()) !== null) { if (Reg1.test(currNode.textContent)) { currNode.textContent = currNode.textContent.replace(Reg1, function(m){ return m.slice(0,6)+'********'+m.slice(-4) }) } } value = (parent.innerText || parent.textContent || '').replace(/\\n/g, ''); if (!value.match(Reg1)) return t = document.createNodeIterator(parent, NodeFilter.SHOW_ELEMENT, null, false) while ((currNode = t.nextNode()) !== null) { if (Reg2.test(currNode.innerText)) { // 从body开始匹配，不用严格会整个替换 currNode.innerText = currNode.innerText.replace(Reg1, function(m){ return m.slice(0,6)+'********'+m.slice(-4) }) } } } recursionDom(document.body) var observer = new MutationObserver(function (mutatinRecords) { // console.log('mutatinRecords', mutatinRecords) mutatinRecords.forEach(function (item) { recursionDom(item.target) }) }) observer.observe(document.body, { childList: true, characterData: true, subtree: true }) } catch (error) { console.log('catch', error) } } document.getElementsByClassName('test-btn')[0].addEventListener('click',function(e){ if(window.afterObserver) return e.target.classList.add('disable') window.afterObserver = true filterIdNO() }) 移动端移动端项目是前后端分离而且走了公共的请求方法； 123456789101112131415161718192021222324252627const IdCardReg = /(?&lt;first&gt;((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|[7-9]1)\\d&#123;4&#125;)((?&lt;year&gt;(18|19|20)\\d&#123;2&#125;)((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31))(?&lt;last&gt;\\d&#123;3&#125;[0-9Xx])/g;function cleanIdno(params) &#123; for (let key in params) &#123; if (typeof params[key] === &#x27;object&#x27;) &#123; cleanIdno(params[key]) &#125; else &#123; if (IdCardReg.test(params[key])) &#123; params[key] = params[key].replace(IdCardReg, function (m) &#123; return `$&#123;m.slice(0, 6)&#125;********$&#123;m.slice(-4)&#125;` &#125;) &#125; &#125; &#125; return params&#125;let http = axios.create(options);http.interceptors.response.use(function (res) &#123; if(res.status == 200)&#123; const data = res.data; return data ? cleanIdno(data) : &#123;&#125; &#125;else&#123; return Promise.reject(res) &#125;&#125;, function (err) &#123; return Promise.reject(err);&#125;);","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"nginx使用","slug":"nginx使用","date":"2023-10-31T17:54:59.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/10/31/nginx使用/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/10/31/nginx%E4%BD%BF%E7%94%A8/","excerpt":"","text":"nginx常用命令 开启：sudo nginx 重载：nginx -s reload 关闭：nginx -s quit 查找配置文件：ngix -t","categories":[],"tags":[]},{"title":"前端分享-2023-07-10","slug":"前端分享-2023-07-10","date":"2023-07-10T16:32:23.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/07/10/前端分享-2023-07-10/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/07/10/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2023-07-10/","excerpt":"分享几个Web API","text":"分享几个Web API Blob APIBlob API 用于处理二进制数据，可以方便地将数据转换为Blob对象或从Blob对象读取数据。使用场景：在Web应用中，可能需要上传或下载二进制文件，使用Blob API可以方便地处理这些数据。 使用blob实现文件下载下载一个html文件 12345678910const html = `&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;` const myBlob = new Blob([html],&#123;type: &#x27;text/html&#x27;&#125;);const oa = document.createElement(&#x27;a&#x27;);oa.href = URL.createObjectURL(blob);oa.download = &#x27;index.html&#x27;;oa.click(); 下载一个excell(这个下载的是个假的excel文件，只有xls格式可以在Excel中打开) 12345678//blob URL形式文件下载var tableHtml=&#x27;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;only one&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&#x27;;var excelBlob = new Blob([tableHtml], &#123;type: &#x27;application/vnd.ms-excel&#x27;&#125;);var oa = document.createElement(&#x27;a&#x27;);oa.href = URL.createObjectURL(excelBlob);oa.download = &#x27;htmltable-blob.xls&#x27;;document.body.appendChild(oa);oa.click(); 使用blob实现图片预览这里对比一下createObjectURL()和readAsDataURL()的区别，两种方法都可以实现图片预览 FileReader.readAsDataURL(file) URL.createObjectURL(file) 返回值 得到一段data:base64的字符串 得到当前文件的一个内存URL 内存使用 返回值是转化后的超长base64字符串(长度与要解析的文件大小正相关)并会比blob url消耗更多内存，但是在不用的时候会自动从内存中清除（通过垃圾回收机制） createObjectURL返回一段带hash的url，并且一直存储在内存中，直到document触发了unload事件（例如：document close）或者执行revokeObjectURL来释放。 内存清理 依照JS垃圾回收机制自动从内存中清理 存在于当前doucment内，清除方式只有unload()事件或revokeObjectURL()手动清除 执行机制 异步执行 同步执行 其他 当多个文件同时处理时，需要每一个文件对应一个新的FileReader对象 依次返回无影响 兼容性 ie10以上的浏览器 ie10以上的浏览器 使用方式： 123456const reader = new FileReader();reader.readAsDataURL(file);reader.onload = ()=&gt;&#123; console.log(reader.result);&#125;const blobUrl = URL.createObjectURL(blob); WeakSet类似于Set，但可以存储弱引用的对象。这意味着，如果没有其他引用指向一个对象，那么这个对象可以被垃圾回收器回收，而不需要手动从WeakSet中删除。 12345678const myWeakSet = new WeakSet();const obj1 = &#123;&#125;;const obj2 = &#123;&#125;;myWeakSet.add(obj1);myWeakSet.add(obj2);console.log(myWeakSet.has(obj1)); // trueobj1 = null;console.log(myWeakSet.has(obj1)); // false 使用场景：在某些情况下，可能需要存储一些临时的对象，但又不希望这些对象占用太多的内存。使用WeakSet可以方便地管理这些对象。 TextEncoder 和 TextDecoderTextEncoder 和 TextDecoder 用于处理字符串和字节序列之间的转换。它们可以方便地将字符串编码为字节序列或将字节序列解码为字符串。 1234567const encoder = new TextEncoder();const decoder = new TextDecoder();const myString = &quot;Hello, world!&quot;;const myBuffer = encoder.encode(myString);console.log(myBuffer); // Uint8Array(13) [72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33]const decodedString = decoder.decode(myBuffer);console.log(decodedString); // &quot;Hello, world!&quot; 使用场景：在Web应用中，可能需要将字符串转换为二进制数据，或将二进制数据转换为字符串。使用TextEncoder和TextDecoder可以方便地进行这些转换。 Proxy API12345678910111213141516const myObject = &#123; name: &quot;John&quot;, age: 30,&#125;;const myProxy = new Proxy(myObject, &#123; get(target, property) &#123; console.log(`Getting property $&#123;property&#125;`); return target[property]; &#125;, set(target, property, value) &#123; console.log(`Setting property $&#123;property&#125; to $&#123;value&#125;`); target[property] = value; &#125;,&#125;);console.log(myProxy.name); // &quot;John&quot;myProxy.age = 31; // Setting property age to 31 使用场景：在某些情况下，可能需要拦截对象属性的读取、赋值等操作，以实现更高级的功能。使用Proxy API可以方便地实现这些功能。 Object.entries() 和 Object.values()Object.entries() 用于获取对象的可枚举属性和值的数组，Object.values() 用于获取对象的可枚举属性值的数组。 123456const myObject = &#123; name: &quot;John&quot;, age: 30,&#125;;console.log(Object.entries(myObject)); // [[&quot;name&quot;, &quot;John&quot;], [&quot;age&quot;, 30]]console.log(Object.values(myObject)); // [&quot;John&quot;, 30] 使用场景：在某些情况下，可能需要获取对象的可枚举属性或属性值。使用Object.entries()和Object.values()可以方便地实现这些功能。 IntersectionObserverIntersectionObserver 可以用于检测元素是否进入视口，可以用于实现无限滚动、懒加载等功能。 12345678910const myObserver = new IntersectionObserver((entries, observer) =&gt; &#123; entries.forEach((entry) =&gt; &#123; if (entry.isIntersecting) &#123; console.log(`$&#123;entry.target.id&#125; is now visible`); observer.unobserve(entry.target); &#125; &#125;);&#125;);const myElement = document.getElementById(&quot;myElement&quot;);myObserver.observe(myElement); 使用场景：在Web应用中，可能需要实现无限滚动、懒加载等功能，使用IntersectionObserver可以方便地实现这些功能。 SymbolSymbol 可以用于创建唯一标识符，可以用于定义对象的私有属性或方法。 1234567const mySymbol = Symbol(&quot;mySymbol&quot;);const myObject = &#123; [mySymbol]: &quot;This is a private property&quot;, publicProperty: &quot;This is a public property&quot;,&#125;;console.log(myObject[mySymbol]); // &quot;This is a private property&quot;console.log(myObject.publicProperty); // &quot;This is a public property&quot; 使用场景：在某些情况下，可能需要定义对象的私有属性或方法，使用Symbol可以方便地实现这些功能。 Reflect APIReflect API 可以用于实现元编程，例如动态调用对象的方法或构造函数。 123456789101112class MyClass &#123; constructor(value) &#123; this.value = value; &#125; getValue() &#123; return this.value; &#125;&#125;const myObject = Reflect.construct(MyClass, [&quot;Hello, world!&quot;]);const myMethod = Reflect.get(myObject, &quot;getValue&quot;);const myValue = myMethod.call(myObject);console.log(myValue); // &quot;Hello, world!&quot; 使用场景：在某些情况下，可能需要动态调用对象的方法或构造函数，使用Reflect API可以方便地实现这些功能。 Generator APIGenerator API 可以用于生成迭代器，可以用于实现异步操作或惰性计算。 123456789function* myGenerator() &#123; yield &quot;Hello&quot;; yield &quot;world&quot;; yield &quot;!&quot;;&#125;const myIterator = myGenerator();console.log(myIterator.next().value); // &quot;Hello&quot;console.log(myIterator.next().value); // &quot;world&quot;console.log(myIterator.next().value); // &quot;!&quot; 使用场景：在某些情况下，可能需要实现异步操作或惰性计算，使用Generator API可以方便地实现这些功能。 Web WorkersWeb Workers 可以用于在后台线程中执行JavaScript代码，可以用于提高性能或实现复杂的计算。 1234567891011// main.jsconst myWorker = new Worker(&quot;worker.js&quot;);myWorker.postMessage(&quot;Hello, worker!&quot;);myWorker.onmessage = (event) =&gt; &#123; console.log(`Message received from worker: $&#123;event.data&#125;`);&#125;;// worker.jsonmessage = (event) =&gt; &#123; console.log(`Message received in worker: $&#123;event.data&#125;`); postMessage(&quot;Hello, main!&quot;);&#125;; 使用场景：在Web应用中，可能需要处理大量计算密集型任务或执行长时间运行的操作，使用Web Workers可以提高性能或避免阻塞用户界面。 AudioContextAudioContext 可以用于处理音频，可以用于实现音频播放、音效处理等功能。 12345678910const audioContext = new AudioContext();fetch(&quot;https://example.com/audio.mp3&quot;) .then((response) =&gt; response.arrayBuffer()) .then((arrayBuffer) =&gt; audioContext.decodeAudioData(arrayBuffer)) .then((audioBuffer) =&gt; &#123; const source = audioContext.createBufferSource(); source.buffer = audioBuffer; source.connect(audioContext.destination); source.start(); &#125;); 使用场景：在Web应用中，可能需要实现音频播放、音效处理等功能，使用AudioContext可以方便地实现这些功能。","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端分享-2023-05-15","slug":"前端分享-2023-05-15","date":"2023-05-15T16:38:54.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/05/15/前端分享-2023-05-15/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/05/15/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2023-05-15/","excerpt":"使用div模拟一个不可编辑的input1234567891011121314151617181920212223&lt;div class=&quot;input-item&quot; placeholder=&quot;点击添加查询企业&quot;&gt;&#123;&#123; company &#125;&#125;&lt;/div&gt;.input-item &#123; width: 790px; height: 128px; line-height: 128px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; font-size: 42px; color: #333333; position: relative; &amp;:empty:after &#123; display: block; content: attr(placeholder); position: absolute; left: 0; top: 0; width: 100%; height: 128px; color: #999999; &#125;&#125; 元素overflow:hidden后，弹窗定位问题1234567891011&lt;!-- 绝对定位元素不总是被父级 overflow 属性裁剪 --&gt;&lt;div class=&quot;div1&quot; style=&quot;overflow: hidden;&quot;&gt; &lt;div class=&quot;div2&quot; style=&quot;position: absolute;&quot;&gt;1&lt;/div&gt;&lt;/div&gt;&lt;!-- 尤其是当 overflow 在绝对定位元素及其包含块之间的时候 --&gt;&lt;div class=&quot;div3&quot; style=&quot;position: relative;&quot;&gt; &lt;div class=&quot;div4&quot; style=&quot;overflow: hidden;&quot;&gt; &lt;div class=&quot;div5&quot; style=&quot;position: absolute;&quot;&gt;2&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 当绝对定位相对于overflow外层的元素定位时，元素不会被裁剪另一种方式时使用fixed定位","text":"使用div模拟一个不可编辑的input1234567891011121314151617181920212223&lt;div class=&quot;input-item&quot; placeholder=&quot;点击添加查询企业&quot;&gt;&#123;&#123; company &#125;&#125;&lt;/div&gt;.input-item &#123; width: 790px; height: 128px; line-height: 128px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; font-size: 42px; color: #333333; position: relative; &amp;:empty:after &#123; display: block; content: attr(placeholder); position: absolute; left: 0; top: 0; width: 100%; height: 128px; color: #999999; &#125;&#125; 元素overflow:hidden后，弹窗定位问题1234567891011&lt;!-- 绝对定位元素不总是被父级 overflow 属性裁剪 --&gt;&lt;div class=&quot;div1&quot; style=&quot;overflow: hidden;&quot;&gt; &lt;div class=&quot;div2&quot; style=&quot;position: absolute;&quot;&gt;1&lt;/div&gt;&lt;/div&gt;&lt;!-- 尤其是当 overflow 在绝对定位元素及其包含块之间的时候 --&gt;&lt;div class=&quot;div3&quot; style=&quot;position: relative;&quot;&gt; &lt;div class=&quot;div4&quot; style=&quot;overflow: hidden;&quot;&gt; &lt;div class=&quot;div5&quot; style=&quot;position: absolute;&quot;&gt;2&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 当绝对定位相对于overflow外层的元素定位时，元素不会被裁剪另一种方式时使用fixed定位 JS 的 6 种加载方式 正常模式 1&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; 这种情况下 JS 会阻塞 dom 渲染，浏览器必须等待 index.js 加载和执行完成后才能去做其它事情 async 模式 1&lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt; async 模式下，它的加载是异步的，JS 不会阻塞 DOM 的渲染，async 加载是无顺序的，当它加载结束，JS 会立即执行 使用场景：若该 JS 资源与 DOM 元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用 async 模式，比如埋点统计 defer 模式 1&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt; defer 模式下，JS 的加载也是异步的，defer 资源会在 DOMContentLoaded 执行之前，并且 defer 是有顺序的加载 如果有多个设置了 defer 的 script 标签存在，则会按照引入的前后顺序执行，即便是后面的 script 资源先返回 所以 defer 可以用来控制 JS 文件的执行顺序，比如 element-ui.js 和 vue.js，因为 element-ui.js 依赖于 vue，所以必须先引入 vue.js，再引入 element-ui.js 12&lt;script defer src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;element-ui.js&quot;&gt;&lt;/script&gt; defer 使用场景：一般情况下都可以使用 defer，特别是需要控制资源加载顺序时 module 模式 1&lt;script type=&quot;module&quot;&gt;import &#123; a &#125; from &#x27;./a.js&#x27;&lt;/script&gt; 在主流的现代浏览器中，script 标签的属性可以加上 type=”module”，浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是 defer 一样，在后台下载，并且等待 DOM 解析 Vite 就是利用浏览器支持原生的 es module 模块，开发时跳过打包的过程，提升编译效率 preload 1&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;index.js&quot;&gt; link 标签的 preload 属性：用于提前加载一些需要的依赖，这些资源会优先加载vue2 项目打包生成的 index.html 文件，会自动给首页所需要的资源，全部添加 preload，实现关键资源的提前加载 preload 特点： preload 加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞 onload 事件； preload 加载的 JS 脚本其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用； prefetch 1&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;index.js&quot;&gt; prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度 prefetch 特点： pretch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟（无论资源是否可以缓存） 当页面跳转时，未完成的 prefetch 请求不会被中断 加载方式总结async、defer 是 script 标签的专属属性，对于网页中的其他资源，可以通过 link 的 preload、prefetch 属性来预加载 如今现代框架已经将 preload、prefetch 添加到打包流程中了，通过灵活的配置，去使用这些预加载功能，同时我们也可以审时度势地向 script 标签添加 async、defer 属性去处理资源，这样可以显著提升性能","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"如何使用svg图标","slug":"如何使用svg图标","date":"2023-04-20T10:06:10.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/04/20/如何使用svg图标/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/04/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8svg%E5%9B%BE%E6%A0%87/","excerpt":"为何要使用字体图标 字体图标更改大小和颜色方便 使得网站整体风格统一 减少网络请求，而使用图片切换时不流畅 UI在线设计工作fiama、蓝湖等可以直接下载svg文件,一些字体库也可以直接下载 怎么将psd中的图标切成svgps直接导出为svg如果不是矢量图，导出的结果是往svg里插入了一张base64图片 怎么把图片转为矢量图 使用ps ps打开图片，使用选择【菜单】-【色彩范围】 直到选中图片上需要的部分，右键建立工作路径 这个时候发现选中的部分被钢笔工具圈出来了，但一般会有误差 然后选中【编辑】-【自定形状】 新建一个空白图层把这个形状添加进去，然后就可以导出了 Adobe Illustrator 将图片导入软件，选择【对象】-【图像描摹】-【建立并拓展】功能 软件就能描摹图片线条，并且生成对应的矢量图。然后我们右键单击图片，选择【收集以导出】-【作为单个资源】 Vector Magic 这款工具是专门做矢量图的不多介绍了 一个工具包 potrace py和node环境都有对应的依赖包，这里以node环境举例： npm install potrace 1234567891011121314151617181920212223242526const potrace = require(&#x27;potrace&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);var params = &#123; // background: &#x27;#49ffd2&#x27;, // color: &#x27;blue&#x27;, // threshold: 120&#125;const dir = path.resolve(&#x27;./pictures&#x27;)if (!fs.existsSync(&#x27;./output&#x27;)) &#123; fs.mkdirSync(&#x27;output&#x27;)&#125; else &#123; fs.readdirSync(&#x27;output&#x27;).forEach(item =&gt; &#123; fs.unlinkSync(path.resolve(&#x27;./output&#x27;, item)) &#125;)&#125;fs.readdirSync(dir).forEach(item =&gt; &#123; potrace.trace(path.join(dir, item), params, function (err, svg) &#123; if (err) throw err; const file = &#x27;./output/&#x27; + item.split(&#x27;.&#x27;)[0] + &#x27;.svg&#x27; fs.writeFileSync(file, svg) console.log(&#x27;写入文件&#x27;, file) &#125;)&#125;)console.log(&#x27;success&#x27;)","text":"为何要使用字体图标 字体图标更改大小和颜色方便 使得网站整体风格统一 减少网络请求，而使用图片切换时不流畅 UI在线设计工作fiama、蓝湖等可以直接下载svg文件,一些字体库也可以直接下载 怎么将psd中的图标切成svgps直接导出为svg如果不是矢量图，导出的结果是往svg里插入了一张base64图片 怎么把图片转为矢量图 使用ps ps打开图片，使用选择【菜单】-【色彩范围】 直到选中图片上需要的部分，右键建立工作路径 这个时候发现选中的部分被钢笔工具圈出来了，但一般会有误差 然后选中【编辑】-【自定形状】 新建一个空白图层把这个形状添加进去，然后就可以导出了 Adobe Illustrator 将图片导入软件，选择【对象】-【图像描摹】-【建立并拓展】功能 软件就能描摹图片线条，并且生成对应的矢量图。然后我们右键单击图片，选择【收集以导出】-【作为单个资源】 Vector Magic 这款工具是专门做矢量图的不多介绍了 一个工具包 potrace py和node环境都有对应的依赖包，这里以node环境举例： npm install potrace 1234567891011121314151617181920212223242526const potrace = require(&#x27;potrace&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);var params = &#123; // background: &#x27;#49ffd2&#x27;, // color: &#x27;blue&#x27;, // threshold: 120&#125;const dir = path.resolve(&#x27;./pictures&#x27;)if (!fs.existsSync(&#x27;./output&#x27;)) &#123; fs.mkdirSync(&#x27;output&#x27;)&#125; else &#123; fs.readdirSync(&#x27;output&#x27;).forEach(item =&gt; &#123; fs.unlinkSync(path.resolve(&#x27;./output&#x27;, item)) &#125;)&#125;fs.readdirSync(dir).forEach(item =&gt; &#123; potrace.trace(path.join(dir, item), params, function (err, svg) &#123; if (err) throw err; const file = &#x27;./output/&#x27; + item.split(&#x27;.&#x27;)[0] + &#x27;.svg&#x27; fs.writeFileSync(file, svg) console.log(&#x27;写入文件&#x27;, file) &#125;)&#125;)console.log(&#x27;success&#x27;) 怎么在项目中使用webpack在webpack项目中使用WebpackIconfontPluginNodejs插件 12345678910111213141516const WebpackIconfontPluginNodejs = require(&#x27;webpack-iconfont-plugin-nodejs&#x27;);module.exports = &#123;var iconDir = &#x27;src/iconfont&#x27;;configureWebpack: config =&gt; &#123; config.plugins.push(new WebpackIconfontPluginNodejs(&#123; fontName: &#x27;pingan-icons&#x27;, cssPrefix: &#x27;ico&#x27;, svgs: path.join(iconDir, &#x27;svgs/*.svg&#x27;), fontsOutput: path.join(iconDir, &#x27;fonts/&#x27;), cssOutput: path.join(iconDir, &#x27;fonts/font.css&#x27;), htmlOutput: path.join(iconDir, &#x27;fonts/_font-preview.html&#x27;), jsOutput: path.join(iconDir, &#x27;fonts/fonts.js&#x27;), formats: [&#x27;ttf&#x27;, &#x27;woff&#x27;, &#x27;svg&#x27;], &#125;)); &#125;&#125; vitevite.config.js 1234567891011121314import &#123; createSvgIconsPlugin &#125; from &#x27;vite-plugin-svg-icons&#x27;export default defineConfig(()=&gt;&#123; return &#123; plugins: [ createSvgIconsPlugin(&#123; iconDirs: [ resolve(process.cwd(), &#x27;src/icons&#x27;) ], symbolId: &#x27;icon-[dir]-[name]&#x27;, customDomId: &#x27;__svg__icons__dom__&#x27;, &#125;), ] &#125;&#125;) 然后定义一个icon组件 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;svg aria-hidden=&quot;true&quot; class=&quot;svg-icon&quot;&gt; &lt;use :xlink:href=&quot;symbolId&quot; /&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;import &#123; defineComponent, computed &#125; from &#x27;vue&#x27;export default defineComponent(&#123; name: &#x27;SvgIcon&#x27;, props: &#123; prefix: &#123; type: String, default: &#x27;icon&#x27;, &#125;, name: &#123; type: String, required: true, &#125; &#125;, setup(props) &#123; const symbolId = computed(() =&gt; `#$&#123;props.prefix&#125;-$&#123;props.name&#125;`) return &#123; symbolId &#125; &#125;,&#125;)&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt;","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/svg/"}]},{"title":"js字符串和字节的互相转换","slug":"js字符串和字节的互相转换","date":"2023-03-24T11:47:11.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/03/24/js字符串和字节的互相转换/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/03/24/js%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/","excerpt":"字符串转字节序列1234567891011121314151617181920212223242526//字符串转字节序列export function stringToByte(str) &#123; var bytes = new Array(); var len, c; len = str.length; for (var i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if (c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) &#123; bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) &#123; bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) &#123; bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); &#125; else &#123; bytes.push(c &amp; 0xFF); &#125; &#125; return bytes;&#125; 字节序列转ASCII码12345678910111213141516171819202122232425//字节序列转ASCII码//[0x24, 0x26, 0x28, 0x2A] ==&gt; &quot;$&amp;C*&quot;export function byteToString(arr) &#123; if (typeof arr === &#x27;string&#x27;) &#123; return arr; &#125; var str = &#x27;&#x27;, _arr = arr; for (var i = 0; i &lt; _arr.length; i++) &#123; var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if (v &amp;&amp; one.length == 8) &#123; var bytesLength = v[0].length; var store = _arr[i].toString(2).slice(7 - bytesLength); for (var st = 1; st &lt; bytesLength; st++) &#123; store += _arr[st + i].toString(2).slice(2); &#125; str += String.fromCharCode(parseInt(store, 2)); i += bytesLength - 1; &#125; else &#123; str += String.fromCharCode(_arr[i]); &#125; &#125; return str;&#125;","text":"字符串转字节序列1234567891011121314151617181920212223242526//字符串转字节序列export function stringToByte(str) &#123; var bytes = new Array(); var len, c; len = str.length; for (var i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if (c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) &#123; bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) &#123; bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) &#123; bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); &#125; else &#123; bytes.push(c &amp; 0xFF); &#125; &#125; return bytes;&#125; 字节序列转ASCII码12345678910111213141516171819202122232425//字节序列转ASCII码//[0x24, 0x26, 0x28, 0x2A] ==&gt; &quot;$&amp;C*&quot;export function byteToString(arr) &#123; if (typeof arr === &#x27;string&#x27;) &#123; return arr; &#125; var str = &#x27;&#x27;, _arr = arr; for (var i = 0; i &lt; _arr.length; i++) &#123; var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if (v &amp;&amp; one.length == 8) &#123; var bytesLength = v[0].length; var store = _arr[i].toString(2).slice(7 - bytesLength); for (var st = 1; st &lt; bytesLength; st++) &#123; store += _arr[st + i].toString(2).slice(2); &#125; str += String.fromCharCode(parseInt(store, 2)); i += bytesLength - 1; &#125; else &#123; str += String.fromCharCode(_arr[i]); &#125; &#125; return str;&#125; base64编码1234567891011121314151617181920212223console.log(Buffer.from(&#x27;张&#x27;)); // e5 bc a0// 可以用toString方法进行进制转换console.log(0xe5.toString(2));console.log(0xbc.toString(2));console.log(0xa0.toString(2)); // 十六进制转为二进制转换后的结果：11100101 10111100 10100000 3 * 8的格式 转化出的每个字节 不得大于64 0~63，转换为二进制最大为6个1，原本八位转换为六位，少了两位，在前面补0// 3 * 8格式 改成 4 * 6的格式// 11100101 10111100 10100000 -&gt; 111001011011110010100000 -&gt; 111001 011011 110010 100000 -&gt; 00111001 00011011 00110010 00100000 // 这样转换后，虽然符合base64规范，但是数据却会大 1/3 因为原来三个字节变成了现在四个字节// 再将其转换为十进制console.log(parseInt(&#x27;00111001&#x27;,2));console.log(parseInt(&#x27;00011011&#x27;,2));console.log(parseInt(&#x27;00110010&#x27;,2));console.log(parseInt(&#x27;00100000&#x27;,2));// 得到57 27 50 32 四个值// 接下来进行编码 64的编码规范 由 A-Z a-z 0-9 +/ 组成的一个表// 用得到的十进制数字，去表中对应位置取值，将值连在一起，就是最终编码结果let str1 = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;str1+= str1.toLowerCase(); // 26 * 2 + 12str1+=&#x27;0123456789+/&#x27;console.log(str1[57] + str1[27] + str1[50] + str1[32]); // 5byg// 这样就编码完成了，就可以进行数据传输了","categories":[],"tags":[]},{"title":"前端优化","slug":"前端优化","date":"2023-03-23T17:10:09.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/03/23/前端优化/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/03/23/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/","excerpt":"","text":"前端优化大概有以下几个方向： 网络优化 页面渲染优化 js优化 图片优化 webpack打包优化 vue优化 react优化 网络优化 DNS预解析 link标签的rel属性设置dns-prefetch，提前获取域名对应的IP地址 使用缓存 减轻服务器压力（强缓存和协商缓存） 使用CDN 用户与服务器的物理距离对响应时间也有影响。 内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 压缩响应 压缩组件通过减少 HTTP 请求产生的响应包的大小，从而降低传输时间的方式来提高性能。从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持（这个请求头会列出一系列的压缩方法） 如果 Web 服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端使用哪种方法进行的压缩 目前许多网站通常会压缩 HTML 文档，脚本和样式表的压缩也是值得的（包括 XML 和 JSON 在内的任何文本响应理论上都值得被压缩）。但是，图片和 PDF 文件不应该被压缩，因为它们本来已经被压缩了。 使用多个域名 Chrome 等现代化浏览器，都会有同域名限制并发下载数的情况，不同的浏览器及版本都不一样，使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗。 避免图片src为空 虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求： IE 向页面所在的目录发送请求； Safari、Chrome、Firefox 向页面本身发送请求； Opera 不执行任何操作。 页面渲染优化Webkit 渲染引擎流程： 处理 HTML 并构建 DOM 树 处理 CSS 构建 CSS 规则树(CSSOM) DOM Tree 和 CSSOM Tree 合成一棵渲染树 Render Tree。 根据渲染树来布局，计算每个节点的位置 调用 GPU 绘制，合成图层，显示在屏幕上 避免css阻塞css影响renderTree的构建，会阻塞页面的渲染，因此应该尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化)的将css资源加载 降低css选择器的复杂度，浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。 减少嵌套：最多不要超过三层，并且后代选择器的开销较高，慎重使用 避免使用通配符，对用到的元素进行匹配即可 利用继承，避免重复匹配和定义 正确使用类选择器和id选择器 避免使用CSS 表达式 css 表达式会被频繁地计算。 使用外链式的js和css 在现实环境中使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，由于 HTML 文档通常不会被配置为可以进行缓存的，所以每次请求 HTML 文档都要下载 JavaScript 和 CSS。所以，如果 JavaScript 和 CSS 在外部文件中，浏览器可以缓存它们，HTML 文档的大小会被减少而不必增加 HTTP 请求数量。 使用字体图标 iconfont 代替图片图标 图片会增加网络请求次数，从而拖慢页面加载时间 iconfont可以很好的缩放并且不会添加额外的请求 首屏加载优化 使用骨架屏或者动画优化用户体验 资源按需加载，首页不需要的资源延迟加载 减少重绘和回流 增加多个节点使用documentFragment：不是真实dom的部分，不会引起重绘和回流 用 translate 代替 top ，因为 top 会触发回流，但是translate不会。所以translate会比top节省了一个layout的时间 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）；opacity 代替 visiability，visiability会触发重绘（paint），但opacity不会。 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 1234for (let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&#x27;.test&#x27;).style.offsetTop)&#125; 尽量少用table布局，table布局的话，每次有单元格布局改变，都会进行整个tabel回流重绘； 最好别频繁去操作DOM节点，最好把需要操作的样式，提前写成class，之后需要修改。只需要修改一次，需要修改的时候，直接修改className，做成一次性更新多条css DOM属性，一次回流重绘总比多次回流重绘要付出的成本低得多； 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame 每次访问DOM的偏移量属性的时候，例如获取一个元素的scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight之类的属性，浏览器为了保证值的正确也会回流取得最新的值，所以如果你要多次操作，最取完做个缓存。更加不要for循环中访问DOM偏移量属性，而且使用的时候，最好定义一个变量，把要需要的值赋值进去，进行值缓存，把回流重绘的次数减少； 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。 JS中的性能优化 使用事件委托 防抖和节流 尽量不要使用JS动画 css3动画和canvas动画都比JS动画性能好 多线程 复杂的计算开启webWorker进行计算，避免页面假死 计算结果缓存 减少运算次数，比如vue中的computed 图片的优化 雪碧图 借助减少http请求次数来进行优化 图片懒加载 在图片即将进入可视区域的时候进行加载 使用CSS3代替图片 有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好 图片压缩 压缩方法有两种，一是通过在线网站进行压缩，二是通过 webpack 插件 image-webpack-loader。它是基于 imagemin 这个 Node 库来实现图片压缩的。 使用渐进式jpeg 使用渐进式jpeg，会提高用户体验 参考文章 使用 webp 格式的图片 webp 是一种新的图片文件格式，它提供了有损压缩和无损压缩两种方式。在相同图片质量下，webp 的体积比 png 和 jpg 更小。 webpack打包优化 缩小loader 匹配范围 优化loader配置 test、include、exclude三个配置项来缩⼩loader的处理范围 推荐include 1include: path.resolve(__dirname, &quot;./src&quot;), resolve.modules resolve.modules用于配置webpack去哪些目录下寻找第三方模块，默认是 node_modules。 寻找第三方，默认是在当前项目目录下的node_modules里面去找，如果没有找到，就会去上一级目录../node_modules找，再没有会去../../node_modules中找，以此类推，和Node.js的模块寻找机制很类似。 如果我们的第三⽅模块都安装在了项⽬根⽬录下，就可以直接指明这个路径。 12345module.exports=&#123; resolve:&#123; modules: [path.resolve(__dirname, &quot;./node_modules&quot;)] &#125;&#125; resolve.extensions resolve.extensions在导⼊语句没带⽂件后缀时，webpack会⾃动带上后缀后，去尝试查找⽂件是否存在。 后缀尝试列表尽量的⼩ 导⼊语句尽量的带上后缀。 抽离css 助mini-css-extract-plugin:本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载 代码压缩 mode:production，使用的是terser-webpack-plugin 123456789module.exports = &#123; // ... optimization: &#123; minimize: true, minimizer: [ new TerserPlugin(&#123;&#125;), ] &#125;&#125; CSS代码压缩 css-minimizer-webpack-plugin 123456789module.exports = &#123; // ... optimization: &#123; minimize: true, minimizer: [ new CssMinimizerPlugin(&#123;&#125;) ] &#125;&#125; Html文件代码压缩 1234567891011 //... plugin:[ new HtmlwebpackPlugin(&#123; ... minify:&#123; minifyCSS:false, // 是否压缩css collapseWhitespace:false, // 是否折叠空格 removeComments:true // 是否移除注释 &#125; &#125;) ] 文件大小压缩 对文件的大小进行压缩，减少http传输过程中宽带的损耗 compression-webpack-plugin 123456new ComepressionPlugin(&#123; test:/.(css|js)$/, // 哪些文件需要压缩 threshold:500, // 设置文件多大开始压缩 minRatio:0.7, // 至少压缩的比例 algorithm:&quot;gzip&quot;, // 采用的压缩算法&#125;) 图片压缩 一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要 1234567891011121314151617181920212223242526272829303132333435363738394041424344 module: &#123; rules: [ &#123; test: /.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name]_[hash].[ext]&#x27;, outputPath: &#x27;images/&#x27;, &#125; &#125;, &#123; loader: &#x27;image-webpack-loader&#x27;, options: &#123; // 压缩 jpeg 的配置 mozjpeg: &#123; progressive: true, quality: 65 &#125;, // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭 optipng: &#123; enabled: false, &#125;, // 使用 imagemin-pngquant 压缩 png pngquant: &#123; quality: &#x27;65-90&#x27;, speed: 4 &#125;, // 压缩 gif 的配置 gifsicle: &#123; interlaced: false, &#125;, // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 webp: &#123; quality: 75 &#125; &#125; &#125; ] &#125;, ]&#125; Tree shaking 去除死代码Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系） 在webpack实现Tree shaking有两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用 css tree shaking 1npm install purgecss-plugin-webpack -D 1234567891011121314const PurgeCssPlugin = require(&#x27;purgecss-webpack-plugin&#x27;) module.exports = &#123; ... plugins:[ new PurgeCssPlugin(&#123; path:glob.sync(`$&#123;path.resolve(&#x27;./src&#x27;)&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件 satelist:function()&#123; return &#123; standard:[&quot;html&quot;] &#125; &#125; &#125;) ] &#125; babel-plugin-transform-runtime减少ES6转化ES5的冗余 代码分离这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可splitChunks主要属性有如下： Chunks，对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1 多线程打包提升打包速度 vue v-for添加key 路由懒加载 第三方插件按需引入 合理使用computed和watch v-for的同时避免使用v-if destory时销毁事件：比如addEventListener添加的事件、setTimeout、setInterval、bus.$on绑定的监听事件等 react map循环展示添加key 路由懒加载 第三方插件按需引入 使用scu，memo或者pureComponent避免不必要的渲染 合理使用useMemo、memo、useCallback useCallback 是针对函数进行“记忆”的，当它依赖项没有发生改变时，那么该函数的引用并不会随着组件的刷新而被重新赋值。当我们觉得一个函数不需要随着组件的更新而更新引用地址的时候，我们就可以使用 useCallback 去修饰它。 React.memo 是对组件进行 “记忆”，当它接收的 props 没有发生改变的时候，那么它将返回上次渲染的结果，不会重新执行函数返回新的渲染结果。 React.useMemo是针对 值计算 的一种“记忆“，当依赖项没有发生改变时，那么无需再去计算，直接使用之前的值，对于组件而言，这带来的一个好处就是，可以减少一些计算，避免一些多余的渲染。当我们遇到一些数据需要在组件内部进行计算的时候，可以考虑一下 React.useMemo","categories":[{"name":"优化","slug":"优化","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端分享-2023-03-23","slug":"前端分享-2023-03-23","date":"2023-03-20T10:05:50.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/03/20/前端分享-2023-03-23/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/03/20/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2023-03-23/","excerpt":"项目环境变量配置 一个Vue CLI项目有三种模式 development模式用于vue-cli-service serve production模式用于vue-cli-service build和vue-cli-service test:e2e test模式用于vue-cli-service test:unit在vue项目中，我们添加.env、.env.dev、.env.product、.env.test这些文件，来配置不同的环境变量另外一种方法，在命令后面直接使用–mode参数 react项目 安装包env-cmd，然后修改scripts 123&quot;script&quot;:&#123; &quot;test&quot;: &quot;env-cmd -f .env.test craco build&quot;&#125; nuxt项目 安装cross-env，这个包可以直接在命令里修改NODE_ENV; 123&quot;script&quot;:&#123; &quot;test&quot;: &quot;cross-env NODE_ENV=test nuxt&quot;&#125; 然后修改nuxt.config.js文件： 1234env:&#123; NODE_ENV: env[process.env.NODE_ENV].NODE_ENV, API_URL: env[process.env.NODE_ENV].API_URL&#125; element级联选择器结果需求：省市区三级选择器，如果选中了省则只传省的名称，下面的市和区不传 12345678910111213141516// 地区数据araOptions = &#123; label:&#x27;广东&#x27;, children: [ &#123; label: &#x27;广州市&#x27;, children: [ &#123; label: &#x27;荔湾区&#x27; &#125; ... ] &#125;, ... ]&#125; 123456789101112131415161718// 例如广东省珠海市下面有三个区，选中珠海市，组件返回的数据格式：[ [&quot;广东&quot;,&quot;珠海市&quot;,&quot;香洲区&quot;] [&quot;广东&quot;,&quot;珠海市&quot;,&quot;斗门区&quot;] [&quot;广东&quot;,&quot;珠海市&quot;,&quot;金湾区&quot;]]// 当一个市下面的区全部选中，服务的需要的数据格式为：var params = &#123; province: [&#x27;广东&#x27;], city: [&#x27;珠海市&#x27;], district: []&#125;// 当选中整个广东省，需要的数据格式如下：var params = &#123; province: [&#x27;广东&#x27;], city: [], district: []&#125; 解决方法： 12345678910111213141516171819202122232425262728function getAreaCheckedData(store)&#123; let list1 = []; let list2 = []; let list3 = []; const traverse = function(nodes)&#123; nodes.forEach(function(item)&#123; if(item.checked)&#123; if(item.level === 1)&#123; list1.push(item.value) &#125;else if(item.level === 2)&#123; list2.push(item.value) &#125;else if(item.level === 3)&#123; list3.push(item.value) &#125; &#125; if(!item.checked &amp;&amp; item.children &amp;&amp; item.children.length&gt;0)&#123; traverse(item.children) &#125; &#125;) &#125; traverse(store.nodes) return &#123; list1: list1, list2: list2, list3: list3 &#125;&#125;var checkedData = getAreaCheckedData(this.$refs.refPicker.store);","text":"项目环境变量配置 一个Vue CLI项目有三种模式 development模式用于vue-cli-service serve production模式用于vue-cli-service build和vue-cli-service test:e2e test模式用于vue-cli-service test:unit在vue项目中，我们添加.env、.env.dev、.env.product、.env.test这些文件，来配置不同的环境变量另外一种方法，在命令后面直接使用–mode参数 react项目 安装包env-cmd，然后修改scripts 123&quot;script&quot;:&#123; &quot;test&quot;: &quot;env-cmd -f .env.test craco build&quot;&#125; nuxt项目 安装cross-env，这个包可以直接在命令里修改NODE_ENV; 123&quot;script&quot;:&#123; &quot;test&quot;: &quot;cross-env NODE_ENV=test nuxt&quot;&#125; 然后修改nuxt.config.js文件： 1234env:&#123; NODE_ENV: env[process.env.NODE_ENV].NODE_ENV, API_URL: env[process.env.NODE_ENV].API_URL&#125; element级联选择器结果需求：省市区三级选择器，如果选中了省则只传省的名称，下面的市和区不传 12345678910111213141516// 地区数据araOptions = &#123; label:&#x27;广东&#x27;, children: [ &#123; label: &#x27;广州市&#x27;, children: [ &#123; label: &#x27;荔湾区&#x27; &#125; ... ] &#125;, ... ]&#125; 123456789101112131415161718// 例如广东省珠海市下面有三个区，选中珠海市，组件返回的数据格式：[ [&quot;广东&quot;,&quot;珠海市&quot;,&quot;香洲区&quot;] [&quot;广东&quot;,&quot;珠海市&quot;,&quot;斗门区&quot;] [&quot;广东&quot;,&quot;珠海市&quot;,&quot;金湾区&quot;]]// 当一个市下面的区全部选中，服务的需要的数据格式为：var params = &#123; province: [&#x27;广东&#x27;], city: [&#x27;珠海市&#x27;], district: []&#125;// 当选中整个广东省，需要的数据格式如下：var params = &#123; province: [&#x27;广东&#x27;], city: [], district: []&#125; 解决方法： 12345678910111213141516171819202122232425262728function getAreaCheckedData(store)&#123; let list1 = []; let list2 = []; let list3 = []; const traverse = function(nodes)&#123; nodes.forEach(function(item)&#123; if(item.checked)&#123; if(item.level === 1)&#123; list1.push(item.value) &#125;else if(item.level === 2)&#123; list2.push(item.value) &#125;else if(item.level === 3)&#123; list3.push(item.value) &#125; &#125; if(!item.checked &amp;&amp; item.children &amp;&amp; item.children.length&gt;0)&#123; traverse(item.children) &#125; &#125;) &#125; traverse(store.nodes) return &#123; list1: list1, list2: list2, list3: list3 &#125;&#125;var checkedData = getAreaCheckedData(this.$refs.refPicker.store);","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"react","slug":"react","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/react/"},{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"}]},{"title":"前端分享-2023-02-10","slug":"前端分享-2023-02-10","date":"2023-02-10T10:29:05.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2023/02/10/前端分享-2023-02-10/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2023/02/10/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2023-02-10/","excerpt":"js模拟点击1234567const clickEvent = new MouseEvent(&#x27;click&#x27;, &#123; view: window, bubbles: true, cancelable: true,&#125;);inputFile.current.disabled = &quot;&quot;;inputFile.current.dispatchEvent(clickEvent); 需求：点击一个按钮，要先判断能否上传文件，如果能上传文件在触发input的点击事件触发文件选择框问题：在Safari中不生效 axios上传文件问题1234567891011121314const http = axios.create(&#123; withCredentials: true, baseURL: process.env.REACT_APP_BASE_URL, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;&#125;);http.interceptors.request.use(function(config) &#123; if (config.url.indexOf(&#x27;/uploadimage&#x27;) &gt;= 0 || config.url.indexOf(&#x27;/uploadfile&#x27;) &gt;= 0) &#123; config.withCredentials = false; config.timeout = 2 * 60 * 1000; &#125; return config&#125;) 上传文件的请求 withCredentials 要改成 false css中的where选择器优先级低，方便用户覆盖，兼容有问题craco配置 把入口文件放到一个目录entries 目录下的每个文件作为一个入口进行打包 每一个入口生成一个同名的html文件 123456789101112131415161718192021222324252627282930313233function configureWebpack(webpackConfig, &#123; env, paths&#125;) &#123; //遍历entries创建多个入口 const entriesDir = path.join(paths.appSrc, &#x27;entries&#x27;); const fileNames = fs.readdirSync(entriesDir); const entries = &#123;&#125;; const htmlWebpackPlugins = []; fileNames.forEach(fileName =&gt; &#123; const filePath = path.join(entriesDir, fileName); const file = fs.statSync(filePath); if (file.isDirectory()) &#123; entries[fileName] = path.join(filePath, &#x27;index.js&#x27;) htmlWebpackPlugins.push(mkHtmlWebpackPlugin([fileName], fileName + &quot;.html&quot;)); &#125; &#125;) //覆盖默认的plugins配置 const defaultHtmlWebpackPluginIndex = webpackConfig.plugins.findIndex(plugin =&gt; plugin instanceof HtmlWebpackPlugin); webpackConfig.plugins.splice(defaultHtmlWebpackPluginIndex, 1, ...htmlWebpackPlugins); webpackConfig = &#123; ...webpackConfig, entry: &#123; main: webpackConfig.entry, ...entries &#125;, externals: &#123; react: &#x27;React&#x27;, &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27; &#125; &#125; return webpackConfig&#125;","text":"js模拟点击1234567const clickEvent = new MouseEvent(&#x27;click&#x27;, &#123; view: window, bubbles: true, cancelable: true,&#125;);inputFile.current.disabled = &quot;&quot;;inputFile.current.dispatchEvent(clickEvent); 需求：点击一个按钮，要先判断能否上传文件，如果能上传文件在触发input的点击事件触发文件选择框问题：在Safari中不生效 axios上传文件问题1234567891011121314const http = axios.create(&#123; withCredentials: true, baseURL: process.env.REACT_APP_BASE_URL, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;&#125;);http.interceptors.request.use(function(config) &#123; if (config.url.indexOf(&#x27;/uploadimage&#x27;) &gt;= 0 || config.url.indexOf(&#x27;/uploadfile&#x27;) &gt;= 0) &#123; config.withCredentials = false; config.timeout = 2 * 60 * 1000; &#125; return config&#125;) 上传文件的请求 withCredentials 要改成 false css中的where选择器优先级低，方便用户覆盖，兼容有问题craco配置 把入口文件放到一个目录entries 目录下的每个文件作为一个入口进行打包 每一个入口生成一个同名的html文件 123456789101112131415161718192021222324252627282930313233function configureWebpack(webpackConfig, &#123; env, paths&#125;) &#123; //遍历entries创建多个入口 const entriesDir = path.join(paths.appSrc, &#x27;entries&#x27;); const fileNames = fs.readdirSync(entriesDir); const entries = &#123;&#125;; const htmlWebpackPlugins = []; fileNames.forEach(fileName =&gt; &#123; const filePath = path.join(entriesDir, fileName); const file = fs.statSync(filePath); if (file.isDirectory()) &#123; entries[fileName] = path.join(filePath, &#x27;index.js&#x27;) htmlWebpackPlugins.push(mkHtmlWebpackPlugin([fileName], fileName + &quot;.html&quot;)); &#125; &#125;) //覆盖默认的plugins配置 const defaultHtmlWebpackPluginIndex = webpackConfig.plugins.findIndex(plugin =&gt; plugin instanceof HtmlWebpackPlugin); webpackConfig.plugins.splice(defaultHtmlWebpackPluginIndex, 1, ...htmlWebpackPlugins); webpackConfig = &#123; ...webpackConfig, entry: &#123; main: webpackConfig.entry, ...entries &#125;, externals: &#123; react: &#x27;React&#x27;, &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27; &#125; &#125; return webpackConfig&#125;","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"js事件循环","slug":"js事件循环","date":"2022-12-16T10:55:06.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/12/16/js事件循环/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/12/16/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"js事件循环JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 Event Loop：所有同步任务在主线程上执行，形成一个执行栈—-&gt;主线程之外还有任务队列，当异步任务执行有结果的时候就会在任务队列放置一个事件——&gt;当执行栈中的同步任务执行完毕，就会读取任务队列中的事件，将其对应的异步任务放入执行栈执行，这个不断循环往复的过程，就称为事件循环，也就是Event Loop 宏任务(macrotask) script setTimeout setInterval setImmediate (Node独有) requestAnimationFrame (浏览器独有) I/O（有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） UI rendering (浏览器独有) 微任务(microtask) process.nextTick(Node独有) Promise MutationObserver 例题一1234567891011console.log(1)​setTimeout(() =&gt; &#123; console.log(2) Promise.resolve().then(() =&gt; console.log(3))&#125;)​new Promise((resolve, rejct) =&gt; &#123; console.log(4) resolve(5)&#125;).then(data =&gt; cosole.log(data))​setTimeout(() =&gt; console.log(6))​console.log(7)​ 点击查看结果： async与awaitasync 就是用来声明一个异步方法，而 await 是用来等待异步方法执行不管 await 后面跟着的是什么， await 都会阻塞后面的代码 例题二1234567891011121314151617181920async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function() &#123; console.log(&#x27;settimeout&#x27;)&#125;)async1()new Promise(function(resolve) &#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;) 点击查看结果： nextTick的原理 nextTick用于下次Dom更新循环结束之后执行延迟回调","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"前端分享-2022-12-15","slug":"前端分享-2022-12-15","date":"2022-12-14T11:35:14.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/12/14/前端分享-2022-12-15/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/12/14/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-12-15/","excerpt":"console.log在写node程序时，使用 console 打印，如果对象里面还是对象时不会展开, 会打印成 [Object] [Array] 如果打印的内容比较长会超过缓冲区大小， terminal 里会显示不全这些情况下可以使用 debugger 搭配 logpoint","text":"console.log在写node程序时，使用 console 打印，如果对象里面还是对象时不会展开, 会打印成 [Object] [Array] 如果打印的内容比较长会超过缓冲区大小， terminal 里会显示不全这些情况下可以使用 debugger 搭配 logpoint package.json mainmain 指的是 npm package 的入口文件，是最古老且最常用的入口文件 module随着 ESM 和打包工具的发展, 许多 package 会打包成多种格式的包如果使用 import 对该库进行导入，则先寻找 module 字段引入，否则引入 main 字段。 exports不在 exports 字段中的模块，即使直接访问路径，也无法引用！示例： 123456789101112131415161718&quot;exports&quot;:&#123; &quot;node&quot;:&#123; &quot;dev&quot;: &quot;...&quot;, &quot;production&quot;: &quot;...&quot; &#125;, &quot;browser&quot;:&#123; &quot;dev&quot;: &quot;...&quot;, &quot;production&quot;: &quot;...&quot; &#125;&#125;// 或者下面这种&quot;exports&quot;:&#123; &quot;.&quot;:&#123; &quot;import&quot;: &quot;...&quot;, &quot;require&quot;: &quot;...&quot; &#125;&#125; scripts定义在 scripts 中的命令，我们通过 npm run &lt;command&gt; 就可以执行。 npm run &lt;command&gt; 是 npm run-script &lt;command&gt; 的简写test 、 start 、 restart 、 stop 这几个命令执行时可以不加 run ；env 是一个内置的命令, npm run env 可以获取到脚本运行时的所有环境变量。 rollup在开发一个包想使用chalk时，遇到的一个问题。","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"快速上手Rollup","slug":"快速上手Rollup","date":"2022-11-28T16:17:41.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/11/28/快速上手Rollup/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/11/28/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRollup/","excerpt":"什么是 Rollup Rollup 是一个 JavaScript 模块打包工具，可以将多个小的代码片段编译为完整的库和应用。与传统的 CommonJS 和 AMD 这一类非标准化的解决方案不同，Rollup 使用的是 ES6 版本 Javascript 中的模块标准。新的 ES 模块可以让你自由、无缝地按需使用你最喜爱的库中那些有用的单个函数。这一特性在未来将随处可用，但 Rollup 让你现在就可以，想用就用。 为什么是 Rollup 这里简单对webpack、gulp、Rollup做一个比较： gulp 是一个构建工具，主要完成代码压缩、编译转化, 可以替代手工实现自动化工作 Webpack 支持 HMR ，有更完整的插件库，适合用于前端工程化开发 Rollup 更小巧，仅仅是一款 ESM 打包器，支持 Tree-shaking 如果您的代码库是基于ES6或者TS，且希望其他人安装后可以直接使用，这个时候就可以使用Rollup 快速开始Rollup 可以通过两种方式使用：使用命令行方式，或者 JavaScript API 方式 直接命令行运行用于浏览器: 12# 编译为一个在 &lt;script&gt; 标签中可用的自运行函数 (&#x27;iife&#x27;)rollup main.js --file bundle.js --format iife 用于 Node.js : 12# 编译为 CommonJS 模块 (&#x27;cjs&#x27;)rollup main.js --file bundle.js --format cjs 同时用于浏览器和 Node.js： 12# 需要为 UMD 格式的包指定一个名称rollup main.js --file bundle.js --format umd --name &quot;myBundle&quot; -f ：是 --format 的缩写。-o ：指定了输出的路径。-c ：指定rollup的配置文件。-w ：监听源文件是否有改动，如果有改动，重新打包。 使用配置文件在项目中创建一个名为 rollup.config.js 的文件，增加如下代码： 12345678export default &#123; input: [&quot;./src/index.js&quot;], output: &#123; file: &quot;./dist/bundle.js&quot;, format: &quot;umd&quot;, name: &quot;experience&quot;, &#125;,&#125;;","text":"什么是 Rollup Rollup 是一个 JavaScript 模块打包工具，可以将多个小的代码片段编译为完整的库和应用。与传统的 CommonJS 和 AMD 这一类非标准化的解决方案不同，Rollup 使用的是 ES6 版本 Javascript 中的模块标准。新的 ES 模块可以让你自由、无缝地按需使用你最喜爱的库中那些有用的单个函数。这一特性在未来将随处可用，但 Rollup 让你现在就可以，想用就用。 为什么是 Rollup 这里简单对webpack、gulp、Rollup做一个比较： gulp 是一个构建工具，主要完成代码压缩、编译转化, 可以替代手工实现自动化工作 Webpack 支持 HMR ，有更完整的插件库，适合用于前端工程化开发 Rollup 更小巧，仅仅是一款 ESM 打包器，支持 Tree-shaking 如果您的代码库是基于ES6或者TS，且希望其他人安装后可以直接使用，这个时候就可以使用Rollup 快速开始Rollup 可以通过两种方式使用：使用命令行方式，或者 JavaScript API 方式 直接命令行运行用于浏览器: 12# 编译为一个在 &lt;script&gt; 标签中可用的自运行函数 (&#x27;iife&#x27;)rollup main.js --file bundle.js --format iife 用于 Node.js : 12# 编译为 CommonJS 模块 (&#x27;cjs&#x27;)rollup main.js --file bundle.js --format cjs 同时用于浏览器和 Node.js： 12# 需要为 UMD 格式的包指定一个名称rollup main.js --file bundle.js --format umd --name &quot;myBundle&quot; -f ：是 --format 的缩写。-o ：指定了输出的路径。-c ：指定rollup的配置文件。-w ：监听源文件是否有改动，如果有改动，重新打包。 使用配置文件在项目中创建一个名为 rollup.config.js 的文件，增加如下代码： 12345678export default &#123; input: [&quot;./src/index.js&quot;], output: &#123; file: &quot;./dist/bundle.js&quot;, format: &quot;umd&quot;, name: &quot;experience&quot;, &#125;,&#125;; 输出的6种格式iife , amd , umd , cjs , esm , system 模块化方案 描述 优点 缺点 iife 是前端模块化早期的产物，它的核心思路是：1、构建一个匿名函数2、立即执行这个函数，外部的依赖通过入参形式传入3、返回该模块的输出 不影响代码体积 1、输出的变量可能影响全局变量，引入依赖包时依赖全局变量2、需要使用者自行维护 script 标签加载顺序 cjs 为了解决 node.js 在模块化上的缺失，2009年 CommonJS 规范首次被提出 完善的模块化方案 只能在 node.js 环境使用 amd 2011年， amdjs-api 被正式提出 1、解决了 IIFE 的缺点2、一套完备的浏览器里 js 文件模块化方案 代码组织形式别扭，可读性差 umd 兼容了 amd 和 CommonJS 抹平了一个包在 AMD 和 CommonJS 里的差异 会产生兼容代码 esm javascript 模块化官方标准格式。 可读性高 部分浏览器不兼容 Rollup 中常用的几个插件 resolve: 将我们编写的源码与依赖的第三方库进行合并 1npm i -D @rollup/plugin-node-resolve 修改 rollup.config.js : 1234567import resolve from &quot;@rollup/plugin-node-resolve&quot;;export default&#123;...plugins: [resolve()],external: [],&#125; commonjs: 使得rollup.js编译支持npm模块和CommonJS模块方式的插件：@rollup/plugin-commonjs babel: 将ES6语法转成ES5 json","categories":[{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"}],"tags":[{"name":"Rollup","slug":"Rollup","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Rollup/"}]},{"title":"编写npm包遇到的问题","slug":"编写npm包遇到的问题","date":"2022-11-16T17:00:31.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/11/16/编写npm包遇到的问题/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/11/16/%E7%BC%96%E5%86%99npm%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"前言最近在编写一个npm包时遇到几个问题，记录下来防止下次卡在同一个地方，后续遇到的坑会继续整理 一、CJS和ESM不能同时使用 问题描述：在编写一个node环境的NPM包时，引用了一个ESM模块机制的包 Node对ESM的支持Node 13.2.0 起开始正式支持ES Modules特性，使用方法如下： 在package.json中，增加&quot;type&quot;:&quot;module&quot; 将文件.js后缀修改为.mjs 上面两种方法二选一，如果不配置，则会抛出警告：Warning: To load an ES module, set &quot;type&quot;: &quot;module&quot; in the package.json or use the .mjs extension.","text":"前言最近在编写一个npm包时遇到几个问题，记录下来防止下次卡在同一个地方，后续遇到的坑会继续整理 一、CJS和ESM不能同时使用 问题描述：在编写一个node环境的NPM包时，引用了一个ESM模块机制的包 Node对ESM的支持Node 13.2.0 起开始正式支持ES Modules特性，使用方法如下： 在package.json中，增加&quot;type&quot;:&quot;module&quot; 将文件.js后缀修改为.mjs 上面两种方法二选一，如果不配置，则会抛出警告：Warning: To load an ES module, set &quot;type&quot;: &quot;module&quot; in the package.json or use the .mjs extension. 如何发布一个支持 Tree Shaking 机制的 npm 包？pkg.main 字段指向的应该是编译后生成的 ES5 版本的代码。pkg.module 字段要指向的应该是一个基于 ES6 模块规范的使用ES5语法书写的模块。要构建一个满足 pkg.module 字段要求的包其实很简单。如果你是使用 Rollup 打包代码， 那么只需要把 output 的格式设置为 es 就可以啦。","categories":[{"name":"问题","slug":"问题","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/npm/"}]},{"title":"前端分享-2022-11-03","slug":"前端分享-2022-11-03","date":"2022-11-03T15:50:11.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/11/03/前端分享-2022-11-03/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/11/03/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-11-03/","excerpt":"遇到的几个问题 时间戳转换日期出现不准确情况123456let t = 577292400000console.log(new Date(t).toLocaleDateString()) //1988/4/18t = t - 24 * 60 * 60 * 1000console.log(new Date(t).toLocaleDateString()) //1988/4/16let t2 = new Date(&#x27;1988/4/17&#x27;).getTime() //577209600000t - t2 === 23 * 60 * 60 * 1000 safari中定位1234.box&#123; position: relative; top: 50%; &#125; 发现用百分比不生效，修改为具体高度后解决","text":"遇到的几个问题 时间戳转换日期出现不准确情况123456let t = 577292400000console.log(new Date(t).toLocaleDateString()) //1988/4/18t = t - 24 * 60 * 60 * 1000console.log(new Date(t).toLocaleDateString()) //1988/4/16let t2 = new Date(&#x27;1988/4/17&#x27;).getTime() //577209600000t - t2 === 23 * 60 * 60 * 1000 safari中定位1234.box&#123; position: relative; top: 50%; &#125; 发现用百分比不生效，修改为具体高度后解决","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"js数组去重","slug":"js数组去重","date":"2022-10-25T09:50:18.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/10/25/js数组去重/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/10/25/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"普通数组（元素为基本类型的）1. 使用Set123Array.from(new Set(arr));[...new Set(arr)];//两种任选一个 2. 新建数组加indexOf123456const newArr = []arr.forEach(item =&gt; &#123; if (newArr.indexOf(item) &lt; 0) &#123; newArr.push(item) &#125;&#125;) 3. 类似前一种，使用includes()判断123456const newArr = []arr.forEach(item =&gt; &#123; if (!newArr.includes(item)) &#123; newArr.push(item) &#125;&#125;) 4. 变量在原数组中出现的第一个位置123456const newArr = []arr.forEach((item, index) =&gt; &#123; if (arr.indexOf(item) === index) &#123; newArr.push(item) &#125;&#125;) 5. filter123const newArr = arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) === index&#125;) 6. 利用两层循环+数组的splice方法(不推荐)","text":"普通数组（元素为基本类型的）1. 使用Set123Array.from(new Set(arr));[...new Set(arr)];//两种任选一个 2. 新建数组加indexOf123456const newArr = []arr.forEach(item =&gt; &#123; if (newArr.indexOf(item) &lt; 0) &#123; newArr.push(item) &#125;&#125;) 3. 类似前一种，使用includes()判断123456const newArr = []arr.forEach(item =&gt; &#123; if (!newArr.includes(item)) &#123; newArr.push(item) &#125;&#125;) 4. 变量在原数组中出现的第一个位置123456const newArr = []arr.forEach((item, index) =&gt; &#123; if (arr.indexOf(item) === index) &#123; newArr.push(item) &#125;&#125;) 5. filter123const newArr = arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) === index&#125;) 6. 利用两层循环+数组的splice方法(不推荐) 对象数组的去重12345const arr = [&#123; key: &#x27;key1&#x27;&#125;, &#123; key: &#x27;key2&#x27;&#125;] 1. 利用对象属性不能相同12345678const newArr = []const obj = &#123;&#125;arr.forEach((item, index) =&gt; &#123; if (!obj.hasOwnProperty(item[&#x27;key&#x27;])) &#123; newArr.push(item) obj[item[&#x27;key&#x27;]] = true &#125;&#125;) 2. 使用Map12345678const newArr = []const map = new Map()arr.forEach((item, index) =&gt; &#123; if (!map.has(item[&#x27;key&#x27;])) &#123; newArr.push(item) map.set(item[&#x27;key&#x27;], true) &#125;&#125;)","categories":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"编写一个cli","slug":"编写一个cli","date":"2022-10-13T14:54:02.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/10/13/编写一个cli/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/10/13/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAcli/","excerpt":"cliCommand Line Interface – 命令行界面为什么要写这个东西？ 可以自己开发一个脚手架 可以更灵活地更改配置 脚手架执行步骤： 在终端输入 vue create vue-test-app 终端解析出 vue命令 终端环境变量中找到vue命令 终端利用node执行vue.js vue.js解析command / options vue.js执行command 执行完毕，退出执行 为什么全局安装完vue-cli 会有一个vue命令？ 在package.json中配置了bin目录，node会在bin目录下配置一个对应的软连接 实现流程1. 初始化一个项目123&gt; mkdir test-cli&gt; cd test-cli&gt; npm init [-y] //创建一个package.json(默认初始值) 2. 注册执行命令 新建目录bin 在这个目录新建文件cli.js 修改package.json, 来告诉npm执行文件位置 1234# package.json&quot;bin&quot;: &#123; &quot;test&quot;: &quot;./bin/cli.js&quot;&#125; 编辑cli.js 123#! /usr/bin/env nodeconsole.log(&#x27;hello world!&#x27;) 3. 模拟执行发布上线再安装测试比较繁琐，且导致版本号膨胀，可以在本地使用 npm link(npm ln) 创建软链接到全局执行 npm link ，会在node的根目录下生成三个文件 12345├──node│ ├──node_modules│ ├──test│ ├──test.cmd│ └──test.ps1 在命令行中输入 test , 会看到打印信息","text":"cliCommand Line Interface – 命令行界面为什么要写这个东西？ 可以自己开发一个脚手架 可以更灵活地更改配置 脚手架执行步骤： 在终端输入 vue create vue-test-app 终端解析出 vue命令 终端环境变量中找到vue命令 终端利用node执行vue.js vue.js解析command / options vue.js执行command 执行完毕，退出执行 为什么全局安装完vue-cli 会有一个vue命令？ 在package.json中配置了bin目录，node会在bin目录下配置一个对应的软连接 实现流程1. 初始化一个项目123&gt; mkdir test-cli&gt; cd test-cli&gt; npm init [-y] //创建一个package.json(默认初始值) 2. 注册执行命令 新建目录bin 在这个目录新建文件cli.js 修改package.json, 来告诉npm执行文件位置 1234# package.json&quot;bin&quot;: &#123; &quot;test&quot;: &quot;./bin/cli.js&quot;&#125; 编辑cli.js 123#! /usr/bin/env nodeconsole.log(&#x27;hello world!&#x27;) 3. 模拟执行发布上线再安装测试比较繁琐，且导致版本号膨胀，可以在本地使用 npm link(npm ln) 创建软链接到全局执行 npm link ，会在node的根目录下生成三个文件 12345├──node│ ├──node_modules│ ├──test│ ├──test.cmd│ └──test.ps1 在命令行中输入 test , 会看到打印信息 主程序编写1. 需要使用的核心库 commander.js: 用来解析各种命令 inquirer.js：命令行交互，创建一个选项列表让用户选择 downloadgitRepo: 下载 chalk: 文字添加颜色，美化输出 2. process.argv可以获取到用户在命令行输入的内容 cli.js文件中添加console.log(process.argv) 执行test aaa, 打印如下结果 12345[ &#x27;D:\\\\node\\\\node.exe&#x27;, &#x27;D:\\\\node\\\\node_modules\\\\chen-cli\\\\bin\\\\cli.js&#x27;, &#x27;aaa&#x27;] 3. 修改 cli.js123456789101112131415161718#! /usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const path = require(&#x27;path&#x27;)program .command(&#x27;create &lt;app-name&gt;&#x27;) .description(&#x27;create a new project&#x27;) .option(&#x27;-f --force&#x27;, &#x27;overwrite target directory if it exist&#x27;) .action((name, options) =&gt; &#123; console.log(&#x27;name:&#x27;, name, &#x27;options&#x27;, options) &#125;)program .version(`v$&#123;require(&#x27;../package.json&#x27;).version&#125;`) .usage(&#x27;&lt;command&gt; [option]&#x27;)program.parse(process.argv) 执行test -V会打印package.json中的版本号 执行test create app -f会触发对应的action方法 4. 编写具体的方法 新建目录lib 在这个目录新建文件create.js 获取项目模板有两种方式，一种是git克隆，另一种内置在项目里 1234567891011121314151617181920212223242526272829303132333435363738394041424344const util = require(&#x27;util&#x27;)const path = require(&#x27;path&#x27;)const downloadgitRepo = require(&#x27;download-git-repo&#x27;)const fs = require(&quot;fs-extra&quot;)const cp = require(&#x27;child_process&#x27;)// const chalk = require(&#x27;chalk&#x27;)async function wrapLoading(fn, message, params) &#123; console.log(message) if (params.type === &#x27;static&#x27;) &#123; // 1:使用内置模板 const targetDir = params.targetDir const templateDir = path.resolve(__dirname, &#x27;../template&#x27;) try &#123; fs.mkdirSync(targetDir) fs.copySync(templateDir, targetDir) &#125; catch (e) &#123; console.log(&#x27;创建失败&#x27;, e) &#125; &#125; else if (params.type === &#x27;git&#x27;) &#123; // 2:git try &#123; // await fn(params.gitUrl, params.targetDir) cp.execSync(`git clone $&#123;params.gitUrl&#125; $&#123;params.targetName&#125;`) &#125; catch (e) &#123; console.log(&#x27;创建失败&#x27;, e) &#125; &#125;&#125;class Generator &#123; constructor() &#123; this.downloadgitRepo = util.promisify(downloadgitRepo) &#125; async download(params) &#123; await wrapLoading( this.downloadgitRepo, &#x27;waiting download template&#x27;, params ) // console.log(`\\r\\nSuccessfully create project $&#123;chalk.cyan(this.name)&#125;`) // console.log(`\\r\\n cd $&#123;chalk.cyan(this.name)&#125;`) // console.log(&#x27;npm run dev\\r\\n&#x27;) &#125;&#125;module.exports = Generator npm发布1. 注册npm账号如果没有账号先去官网注册一个访问npm官网; 注册一个账号 2. 发布域级包为了避免命名冲突 npm官网点击头像，选择下拉框中的Add Organization 添加后得到了名称name 下次初始化时npm init --scope=name 如果是开发完的包, 直接修改package.json中的name属性 1&quot;name&quot;: &quot;@name/test-cli&quot;, 3. 还原仓库地址使用了淘宝镜像的要修改回官方地址 1npm config set registry https://registry.npmjs.org/ 4. 上传发布 npm whoami可以看登录信息 未登录的使用npm login npm publish发布 如果返回E402错误，使用npm publish --access public 发布成功后可以安装使用 5. 修改提交每次修改后要改版本号，不能提交相同的； 主版本号(major)：当你做了不兼容的API修改 次版本号(minor)：当你做了向下兼容的功能性新增 修订号(patch)：当你做了向下兼容的问题修正 12npm version patchnpm publish 另外还有先行版本；当要发行大版本或者核心功能时，不能保证这个版本完全正常，就要先发一个先行版本常见的先行版本号有： alpha：不稳定版本，一般而言，该版本的Bug较多，需要继续修改，是测试版本 beta：基本稳定，相对于Alpha版已经有了很大的进步，消除了严重错误 rc：和正式版基本相同，基本上不存在导致错误的Bug release：最终版本 6. 版本撤回 npm unpublish [pkg]@[version]","categories":[{"name":"工具","slug":"工具","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"cli","slug":"cli","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/cli/"},{"name":"node","slug":"node","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/node/"}]},{"title":"前端分享-2022-09-15","slug":"前端分享-2022-09-15","date":"2022-09-15T15:06:48.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/09/15/前端分享-2022-09-15/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/09/15/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-09-15/","excerpt":"node版本管理工具nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰mac环境推荐使用n 图片裁剪地址 js大数字问题超出 2 的 53 次方之后，一个数就不精确了 123456Number.MAX_SAFE_INTEGER === 9007199254740991handleResData(str)&#123; str = str.replace(/[:]([0-9]&#123;18,&#125;)[,]?/g,`:&quot;$1&quot;,`); return JSON.parse(str)&#125;","text":"node版本管理工具nvm 是 Node.js 的版本管理工具，可以创建不同版本 Node 的隔离环境，从而避免不同版本包之间的干扰mac环境推荐使用n 图片裁剪地址 js大数字问题超出 2 的 53 次方之后，一个数就不精确了 123456Number.MAX_SAFE_INTEGER === 9007199254740991handleResData(str)&#123; str = str.replace(/[:]([0-9]&#123;18,&#125;)[,]?/g,`:&quot;$1&quot;,`); return JSON.parse(str)&#125;","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"}]},{"title":"前端分享-2022-07-28","slug":"前端分享-2022-07-28","date":"2022-07-28T15:13:49.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/07/28/前端分享-2022-07-28/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/07/28/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-07-28/","excerpt":"NUXTNUXT 简介 Nuxt.js 是一个基于 Vue.js 的服务端渲染应用框架，它可以帮我们轻松的实现同构应用。 SSR是英文server side render的缩写，即服务端描画。 NUXT 解决了什么问题 SPA随着工程不断变大，打包文件不断增长，页面的整体刷新加载速度慢。 为了SEO NUXT 会带来的问题 更长的链路，之前是浏览器+nginx+后台服务，而现在就变成浏览器+nginx+nodejs+后台服务。 nodejs中的阻塞型请求，容易成为性能的瓶颈。 一套api，要考虑前后端的兼容性。","text":"NUXTNUXT 简介 Nuxt.js 是一个基于 Vue.js 的服务端渲染应用框架，它可以帮我们轻松的实现同构应用。 SSR是英文server side render的缩写，即服务端描画。 NUXT 解决了什么问题 SPA随着工程不断变大，打包文件不断增长，页面的整体刷新加载速度慢。 为了SEO NUXT 会带来的问题 更长的链路，之前是浏览器+nginx+后台服务，而现在就变成浏览器+nginx+nodejs+后台服务。 nodejs中的阻塞型请求，容易成为性能的瓶颈。 一套api，要考虑前后端的兼容性。 VUE3VUE3介绍","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"}]},{"title":"快速上手vue3","slug":"快速上手vue3","date":"2022-07-15T16:14:14.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/07/15/快速上手vue3/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/07/15/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bvue3/","excerpt":"vue3的优势 Vue3使用TS重构了项目，获得更好的类型支持。 TypeScript 增加了代码的可读性和可维护性 引入了接口、类、继承的编程思想 ts是js的超集，支持所有es6语法 ts在编译时会有错误提示，js在运行时才能暴露错误（大型应用测试很难覆盖到全部代码） ts是强类型语言，可读性强，方便迭代 (不是「强类型」，是「静态类型检查」的「弱类型」) TypeScript 的类型系统是图灵完备的，可以定义从简单到复杂的几乎一切类型 新建小程序项目可以发现默认的模板是ts 重构了响应式系统 更好的Tree shaking Tree-shaking其实就是把无用的模块进行“剪枝”，很多没有用到的 API 就不会打包到最后的包里 比Vue 2更强 重写了虚拟Dom的实现 编译模板的优化。 更高效的组件初始化。 update性能提高1.3~2倍。 SSR速度提高了2~3倍。 Composition API 暴露自定义渲染API Composition API Options API与Composition API对比 Options API 伪代码 Composition API 伪代码 export default &#123; name: ..., data() &#123; return &#123; // 功能A // 功能B ... &#125; &#125;, methods: &#123; // 功能A // 功能B ... &#125;, created() &#123; // 功能A // 功能B ... &#125; &#125; import &#123; defineComponent &#125; from 'vue' export default defineComponent(&#123; setup(props,context)&#123; // 功能A // 功能B ... return&#123; ... &#125; &#125; &#125;) Composition API这里仅介绍setup语法糖用法，函数式写法请参考vue3文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt; script setup &gt; import &#123; ref, reactive, defineExpose, defineProps, defineEmits, onMounted, nextTick, computed， watch &#125; from &#x27;vue&#x27;import &#123; useStore&#125; from &#x27;vuex&#x27;import myLogo from &#x27;@/components/myLogo&#x27; //引入的组件不需要再注册const store = useStore() //获取vuex商店const userInfo = computed(() =&gt; store.state.userInfo)const props = defineProps(&#123; item: &#123; type: Object, default: null &#125;&#125;)onMounted(() =&gt; &#123; modelA()&#125;)const list = ref(null) // 1. ref底层还是调用的reactiveconst element = ref(null) // 2. ref的另一个用法，添加到元素的ref属性，将元素赋值给这个变量const list2 = reactive(&#123; a: 1, b: 2&#125;)function modelA() &#123; request(&#123; ... &#125;).then(res =&gt; &#123; // 3. js中需要通过.value才能操作数据，template模板中可以直接访问 list.value = res.data; list2.a = res.data.no; // 4. 不能重新给list2赋值，否则会断开响应式 // list2 = &#123; // ... // &#125; &#125;).catch(err =&gt; &#123; &#125;)&#125;// 5. 给父组件传参方式const emit = defineEmits([&#x27;choose&#x27;])function handleClick() &#123; emit(&#x27;choose&#x27;, [arg])&#125;// 6. setup中定义的变量、方法在外部组件不可见，通过defineExpose暴露出去defineExpose(&#123; modelA &#125;) &lt; /script&gt;","text":"vue3的优势 Vue3使用TS重构了项目，获得更好的类型支持。 TypeScript 增加了代码的可读性和可维护性 引入了接口、类、继承的编程思想 ts是js的超集，支持所有es6语法 ts在编译时会有错误提示，js在运行时才能暴露错误（大型应用测试很难覆盖到全部代码） ts是强类型语言，可读性强，方便迭代 (不是「强类型」，是「静态类型检查」的「弱类型」) TypeScript 的类型系统是图灵完备的，可以定义从简单到复杂的几乎一切类型 新建小程序项目可以发现默认的模板是ts 重构了响应式系统 更好的Tree shaking Tree-shaking其实就是把无用的模块进行“剪枝”，很多没有用到的 API 就不会打包到最后的包里 比Vue 2更强 重写了虚拟Dom的实现 编译模板的优化。 更高效的组件初始化。 update性能提高1.3~2倍。 SSR速度提高了2~3倍。 Composition API 暴露自定义渲染API Composition API Options API与Composition API对比 Options API 伪代码 Composition API 伪代码 export default &#123; name: ..., data() &#123; return &#123; // 功能A // 功能B ... &#125; &#125;, methods: &#123; // 功能A // 功能B ... &#125;, created() &#123; // 功能A // 功能B ... &#125; &#125; import &#123; defineComponent &#125; from 'vue' export default defineComponent(&#123; setup(props,context)&#123; // 功能A // 功能B ... return&#123; ... &#125; &#125; &#125;) Composition API这里仅介绍setup语法糖用法，函数式写法请参考vue3文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt; script setup &gt; import &#123; ref, reactive, defineExpose, defineProps, defineEmits, onMounted, nextTick, computed， watch &#125; from &#x27;vue&#x27;import &#123; useStore&#125; from &#x27;vuex&#x27;import myLogo from &#x27;@/components/myLogo&#x27; //引入的组件不需要再注册const store = useStore() //获取vuex商店const userInfo = computed(() =&gt; store.state.userInfo)const props = defineProps(&#123; item: &#123; type: Object, default: null &#125;&#125;)onMounted(() =&gt; &#123; modelA()&#125;)const list = ref(null) // 1. ref底层还是调用的reactiveconst element = ref(null) // 2. ref的另一个用法，添加到元素的ref属性，将元素赋值给这个变量const list2 = reactive(&#123; a: 1, b: 2&#125;)function modelA() &#123; request(&#123; ... &#125;).then(res =&gt; &#123; // 3. js中需要通过.value才能操作数据，template模板中可以直接访问 list.value = res.data; list2.a = res.data.no; // 4. 不能重新给list2赋值，否则会断开响应式 // list2 = &#123; // ... // &#125; &#125;).catch(err =&gt; &#123; &#125;)&#125;// 5. 给父组件传参方式const emit = defineEmits([&#x27;choose&#x27;])function handleClick() &#123; emit(&#x27;choose&#x27;, [arg])&#125;// 6. setup中定义的变量、方法在外部组件不可见，通过defineExpose暴露出去defineExpose(&#123; modelA &#125;) &lt; /script&gt; 生命周期对比123456789101112Vue2--------------vue3beforeCreate -&gt; setup()created -&gt; setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountedactivated -&gt; onActivateddeactivated -&gt; onDeactivatederrorCaptured -&gt; onErrorCaptured vue3注意点 放弃了对ie11的支持（proxy） 不再使用this 删除了onBeforeCreate和onCreated。因为setup总是在创建组件实例时调用 给vue2开了个口子，旧的options api也能用 移除了filter，可以使用function和computed替代 vue3不限制单个根标签 避免写面条式代码 pinia vuex已停止接受新功能，推荐vue3中使用pinia 对于typescript支持更好 移除了mutation使用方法和vuex类似，这里不多介绍了什么是pinia","categories":[{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue3/"}]},{"title":"es6整理","slug":"es6整理","date":"2022-06-30T09:57:36.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/06/30/es6整理/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/06/30/es6%E6%95%B4%E7%90%86/","excerpt":"class类中的方法12345678class Test &#123; constructor() &#123; //... &#125; toString() &#123; //不需要加function关键字 &#125;&#125; 12345//一次向类添加多个方法Object.assign(Test.prototype, &#123; toValue() &#123;&#125;, toValue2() &#123;&#125;&#125;) 类中的方法是定义在原型上面；在实例上调用方法，其实就是调用原型上的方法 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 实例属性的新写法除了在constructor()里面的this上面，也可以定义在类内部的最顶层 123&#123; _count = 0;&#125; 新写法定义的属性是实例对象自身的属性，而不是在原型上 Class表达式123const MyClass = class Me &#123; ...&#125; 这个类的名字是Me, Me只在class的内部可以使用，在class外部只能用MyClass引用 可以写立即执行的class 12345let person = new class &#123; constructor(name) &#123; this.name = name &#125;&#125;(&#x27;name&#x27;) 静态方法 使用static关键字，表示该方法不会被实例继承，而是直接通过类来调用 静态方法中的this指的是类本身 父类的静态方法可被子类继承 静态方法可以从super对象上调用 非静态方法不能使用this关键字访问静态方法 静态属性1234class Foo &#123; static prop1 = 1;&#125;Foo.prop = 1; 私有方法和私有属性私有字段在类声明的构造方法中可被访问（只能在类的内部访问的方法和属性） 定义在类外部，在类内部调用 将方法名命名为一个Symbol 使用#前缀来定义 12345678910class ClassA &#123; #privateField; constructor() &#123; this.#privateField = 1; delete this.#privateField; //语法错误 this.#test = 1; //语法错误 &#125;&#125;const instance = new ClassA()instance.#privateField === 1; //语法错误","text":"class类中的方法12345678class Test &#123; constructor() &#123; //... &#125; toString() &#123; //不需要加function关键字 &#125;&#125; 12345//一次向类添加多个方法Object.assign(Test.prototype, &#123; toValue() &#123;&#125;, toValue2() &#123;&#125;&#125;) 类中的方法是定义在原型上面；在实例上调用方法，其实就是调用原型上的方法 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 实例属性的新写法除了在constructor()里面的this上面，也可以定义在类内部的最顶层 123&#123; _count = 0;&#125; 新写法定义的属性是实例对象自身的属性，而不是在原型上 Class表达式123const MyClass = class Me &#123; ...&#125; 这个类的名字是Me, Me只在class的内部可以使用，在class外部只能用MyClass引用 可以写立即执行的class 12345let person = new class &#123; constructor(name) &#123; this.name = name &#125;&#125;(&#x27;name&#x27;) 静态方法 使用static关键字，表示该方法不会被实例继承，而是直接通过类来调用 静态方法中的this指的是类本身 父类的静态方法可被子类继承 静态方法可以从super对象上调用 非静态方法不能使用this关键字访问静态方法 静态属性1234class Foo &#123; static prop1 = 1;&#125;Foo.prop = 1; 私有方法和私有属性私有字段在类声明的构造方法中可被访问（只能在类的内部访问的方法和属性） 定义在类外部，在类内部调用 将方法名命名为一个Symbol 使用#前缀来定义 12345678910class ClassA &#123; #privateField; constructor() &#123; this.#privateField = 1; delete this.#privateField; //语法错误 this.#test = 1; //语法错误 &#125;&#125;const instance = new ClassA()instance.#privateField === 1; //语法错误","categories":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"前端分享-2022-06-09","slug":"前端分享-2022-06-09","date":"2022-06-06T17:38:36.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/06/06/前端分享-2022-06-09/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/06/06/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-06-09/","excerpt":"几个比较实用的git命令12345678910111213141516&lt;!-- 拉取远程代码 --&gt;git fetch --allgit reset --hard origin/master&lt;!-- 暂存 --&gt;git stashgit stash pop&lt;!-- 把一个分支转移到另一个分支 --&gt;git cherry-pick &lt;commitHash&gt;git cherry-pick &lt;id1&gt;..&lt;id2&gt;&lt;!-- 改写上一次提交信息 --&gt;git commit -v --amend&lt;!-- 清除未跟踪的文件 --&gt;git clean -f --d&lt;!-- 清除ignore之前提交的文件 --&gt;git rm -r --cached css分享 小程序css变量 123456/* 解决iPhonex 虚拟按键 */padding-bottom: calc(8px + constant(safe-area-inset-bottom));padding-bottom: calc(8px + env(safe-area-inset-bottom));/* css变量 */--loading-grey: #f1f1f1;background-color: var(--loading-grey, red); 骨架屏 1234567891011121314@keyframes loading &#123; /* to &#123; background-position-x: -20%; &#125; */ 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 0.6; &#125; 100% &#123; opacity: 1; &#125;&#125; 粘性定位 1position: sticky;","text":"几个比较实用的git命令12345678910111213141516&lt;!-- 拉取远程代码 --&gt;git fetch --allgit reset --hard origin/master&lt;!-- 暂存 --&gt;git stashgit stash pop&lt;!-- 把一个分支转移到另一个分支 --&gt;git cherry-pick &lt;commitHash&gt;git cherry-pick &lt;id1&gt;..&lt;id2&gt;&lt;!-- 改写上一次提交信息 --&gt;git commit -v --amend&lt;!-- 清除未跟踪的文件 --&gt;git clean -f --d&lt;!-- 清除ignore之前提交的文件 --&gt;git rm -r --cached css分享 小程序css变量 123456/* 解决iPhonex 虚拟按键 */padding-bottom: calc(8px + constant(safe-area-inset-bottom));padding-bottom: calc(8px + env(safe-area-inset-bottom));/* css变量 */--loading-grey: #f1f1f1;background-color: var(--loading-grey, red); 骨架屏 1234567891011121314@keyframes loading &#123; /* to &#123; background-position-x: -20%; &#125; */ 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 0.6; &#125; 100% &#123; opacity: 1; &#125;&#125; 粘性定位 1position: sticky; 小程序中取高度 scroll-view组件必需给定高度才能触发滑动加载更多 12345678910const windowHeight = uni.getSystemInfoSync().windowHeight;this.scrollHeight = windowHeight;const stickyBar = uni.createSelectorQuery().select(&#x27;.stickyBar&#x27;)stickyBar.boundingClientRect((data) =&gt; &#123; this.scrollHeight -= data.height&#125;).exec()const footerBar = uni.createSelectorQuery().select(&#x27;.footerBar&#x27;)footerBar.boundingClientRect((data) =&gt; &#123; this.scrollHeight -= data.height&#125;).exec() scroll-view组件中fixed定位失效问题 将要定位的元素移到scroll-view组件外 标题栏高度 1234const rect = uni.getMenuButtonBoundingClientRect(); //胶囊const navigation = uni.getSystemInfoSync() //状态栏const statusHeight = navigation.statusBarHeightconst titleBarHeight = (rect.top - statusHeight) * 2 + rect.height; ES6中的默认参数123456const &#123;a=1&#125; = res// 当res中没有a属性或者属性值为undefined，会赋默认值function test(a=1)&#123; console.log(a)&#125;// 当不传参或传undefined，会赋默认值","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"}]},{"title":"前端分享-2022-04-21","slug":"前端分享-2022-04-21","date":"2022-04-21T11:02:16.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/04/21/前端分享-2022-04-21/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/04/21/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-04-21/","excerpt":"word转html标签处理一些内容比较多的文档，如用户协议之类 123456789101112131415161718192021222324from docx import Documentdocument = Document(&#x27;XXXX.docx&#x27;)str = &#x27;&lt;html&gt;&#x27;str += &#x27;&lt;style&gt;.paragraph &#123;text-indent: 30px;&#125;.bold &#123;font-weight: bold;&#125;.underline &#123;text-decoration: underline;&#125;&lt;/style&gt;&#x27;for p in document.paragraphs: str += &#x27;&lt;p class=&quot;paragraph&quot;&gt;&#x27; for n in p.runs: if(n.font.color.rgb): style = &#x27;color:#&#123;&#125;;&#x27;.format(n.font.color.rgb) if(n.bold): classList = &#x27;bold&#x27; if(n.underline): classList = classList + &#x27; underline&#x27; if classList else &#x27;underline&#x27; if(classList): str += &#x27;&lt;span class=&quot;&#123;&#125;&quot; style=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/span&gt;&#x27;.format(classList,style,n.text) else: str += n.text str += &#x27;&lt;/p&gt;&#x27;str += &#x27;&lt;/html&gt;&#x27;f = open(&#x27;XXXX.html&#x27;, &quot;wb&quot;)f.write(bytes(str, &#x27;utf-8&#x27;))f.close()print(&#x27;success&#x27;)","text":"word转html标签处理一些内容比较多的文档，如用户协议之类 123456789101112131415161718192021222324from docx import Documentdocument = Document(&#x27;XXXX.docx&#x27;)str = &#x27;&lt;html&gt;&#x27;str += &#x27;&lt;style&gt;.paragraph &#123;text-indent: 30px;&#125;.bold &#123;font-weight: bold;&#125;.underline &#123;text-decoration: underline;&#125;&lt;/style&gt;&#x27;for p in document.paragraphs: str += &#x27;&lt;p class=&quot;paragraph&quot;&gt;&#x27; for n in p.runs: if(n.font.color.rgb): style = &#x27;color:#&#123;&#125;;&#x27;.format(n.font.color.rgb) if(n.bold): classList = &#x27;bold&#x27; if(n.underline): classList = classList + &#x27; underline&#x27; if classList else &#x27;underline&#x27; if(classList): str += &#x27;&lt;span class=&quot;&#123;&#125;&quot; style=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/span&gt;&#x27;.format(classList,style,n.text) else: str += n.text str += &#x27;&lt;/p&gt;&#x27;str += &#x27;&lt;/html&gt;&#x27;f = open(&#x27;XXXX.html&#x27;, &quot;wb&quot;)f.write(bytes(str, &#x27;utf-8&#x27;))f.close()print(&#x27;success&#x27;) gulp的简单用例 官方介绍：gulp是一个工具包，可帮助您自动化开发工作流程中繁重而耗时的任务。 gulp是工具链、构建工具。可以配合各种插件做js压缩，css压缩，less编译等，可以替代手工实现自动化工作。webpack是文件打包工具，可以把项目的各种js文件、css文件等打包合并成一个或多个文件，主要用于模块化方案，预编译模块的方案。 实现实时scss转wxss根目录下创建gulpfile.js 123456789101112131415161718192021222324252627282930313233343536const gulp = require(&quot;gulp&quot;);const through = require(&quot;through2&quot;);const sass = require(&#x27;gulp-sass&#x27;)(require(&#x27;sass&#x27;));const rename = require(&quot;gulp-rename&quot;);const replace = require(&quot;gulp-replace&quot;);sass.compiler = require(&quot;node-sass&quot;);function scssToCss(filePath) &#123; let destinationPath = filePath.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;) return ( gulp .src(filePath) .pipe(sass().on(&quot;error&quot;, sass.logError)) .pipe(replaceImportCss()) .pipe( rename(function(path) &#123; path.extname = &quot;.wxss&quot;; &#125;) ) .pipe(gulp.dest(destinationPath)) );&#125;let replaceImportCss = () =&gt; &#123; return replace(/url\\((.+\\.css)\\)/g, (match, $1) =&gt; &#123; console.log(match, $1); return `&quot;$&#123;$1&#125;&quot;`; &#125;);&#125;;exports.default = function() &#123; let watcher = gulp.watch([&quot;./**/*.scss&quot;, &quot;!./node_modules/**/*.scss&quot;]); watcher.on(&quot;change&quot;, function (path) &#123; scssToCss(path); &#125;); watcher.on(&quot;unlink&quot;, function(path) &#123; console.log(`File $&#123;path&#125; was removed`); &#125;);&#125;; 将uni-app代码转vue123456789101112131415161718192021222324252627282930313233343536//750rpx=&gt;1080pxfunction convertFile() &#123; var stream = through.obj(function(file, encoding, callback) &#123; if (!file.isBuffer()) &#123; return callback(); &#125; let fileContent = file.contents.toString(&quot;utf8&quot;) || &quot;&quot;; let newFileCon = fileContent.replace(/([\\d.]+)rpx/g, function(match, $1) &#123; return (Number($1) * 1080 / 750).toFixed(2) + &#x27;px&#x27;; &#125;) .replace(/&lt;view([\\s\\S]*?)&gt;/gi, &quot;&lt;div $1&gt;&quot;) .replace(/&lt;\\/\\s?view&gt;/gi, &quot;&lt;/div&gt;&quot;) .replace(/&lt;image([\\s\\S]*?)&gt;/gi, &quot;&lt;img $1&gt;&quot;) .replace(/&lt;\\/\\s?image&gt;/gi, &quot;&quot;) if (newFileCon !== fileContent) &#123; file.contents = Buffer.from(newFileCon); &#125; else &#123; this.emit(&quot;end&quot;); return; &#125; this.push(file); callback(); &#125;); return stream;&#125;function transferVue(filePath) &#123; let destinationPath = filePath.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;) return ( gulp .src(filePath) .pipe(rpx2px()) .pipe(gulp.dest(&#x27;./h5&#x27;)) );&#125; eventEmitter的简单使用方法eventEmitter.js app.js 1234567891011121314151617const EventEmitter = require(&#x27;./utils/eventEmitter.js&#x27;);const eventBus = new EventEmitter();App(&#123; eventBus, onLaunch()&#123; this.getData &#125;, getData()&#123; wx.request(&#123; ..., success(&#123;data&#125;)&#123; this.globalData.loginData = data eventBus.emit(&#x27;afterGetData&#x27;, data) &#125; &#125;) &#125;&#125;) index.js 12345678910111213const app = getApp()Page(&#123; onLoad:function(options)&#123; if(app.globalData.loginData)&#123; this.loginData = app.globalData.loginData &#125;else&#123; app.eventBus.on(&#x27;afterGetData&#x27;,(data)=&gt;&#123; this.loginData = app.globalData.loginData &#125;) &#125; &#125;&#125;)","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"word2html","slug":"word2html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/word2html/"},{"name":"gulp","slug":"gulp","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/gulp/"}]},{"title":"前端分享-2022-03-03","slug":"前端分享-2022-03-03","date":"2022-03-03T11:32:50.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/03/03/前端分享-2022-03-03/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/03/03/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2022-03-03/","excerpt":"运算符 空值合并运算符 1234let a1 = obj.a || 1 //布尔逻辑运算符 (0,&#x27;&#x27;,NaN,null,undefined,false)会转换成falselet a2 = obj.a ? obj.a : 1let a3 = obj.a ?? &#x27;a&#x27; //空值合并运算符 可选链操作符 123let c1 = obj?.c?.c1let c2 = obj?.c?.[0]let c3 = obj?.c?.c2?.() 展开语法 123456789101112131415161718192021// 1、函数调用：test(...list1)// 2、字面量数组构造或字符串：console.log([...list1, &#x27;4&#x27;, ...&#x27;test&#x27;])console.log(...list1)console.log([...new Set(list1)])// &lt;Hello params=&#123;...params&#125;&gt;// 3、构造字面量对象时,进行克隆或者属性拷贝const obj1 = &#123; a: &#123; b: 1, c: undefined, d: function() &#123;&#125;, e: /^\\d&#123;1&#125;/ &#125;&#125;const obj2 = &#123; ...obj1&#125;const obj3 = Object.assign(&#123;&#125;, obj1)const obj4 = JSON.parse(JSON.stringify(obj1)) //&#123;&quot;a&quot;:&#123;&quot;b&quot;:1,&quot;e&quot;:&#123;&#125;&#125;&#125; requestAnimationFrame 屏幕刷新频率：屏幕每秒出现图像的次数。普通笔记本为60Hz 动画原理：计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。 setTimeout：通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是： settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚； settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。 requestAnimationFrame的优势： 由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿 CPU节能，当页面被隐藏或最小化时，setTimeout 仍然在后台执行，requestAnimationFrame会停止渲染 12345678910111213141516171819202122232425262728293031myAnimation(&#123; target, time, inAnimation, afterAnimation&#125;) &#123; let aniId = null let currentNo = 0 const startTime = new Date().getTime() const p = (time * time) / target const render = () =&gt; &#123; const timeRange = new Date().getTime() - startTime; currentNo = timeRange * timeRange / p currentNo = currentNo &gt;= target ? target : currentNo if (inAnimation &amp;&amp; typeof inAnimation === &#x27;function&#x27;) &#123; inAnimation(currentNo) &#125; if (currentNo &lt; target) &#123; aniId = requestAnimationFrame(render) &#125; else &#123; cancelAnimationFrame(aniId) if (afterAnimation &amp;&amp; typeof afterAnimation === &#x27;function&#x27;) &#123; afterAnimation() &#125; &#125; &#125; aniId = requestAnimationFrame(render)&#125;","text":"运算符 空值合并运算符 1234let a1 = obj.a || 1 //布尔逻辑运算符 (0,&#x27;&#x27;,NaN,null,undefined,false)会转换成falselet a2 = obj.a ? obj.a : 1let a3 = obj.a ?? &#x27;a&#x27; //空值合并运算符 可选链操作符 123let c1 = obj?.c?.c1let c2 = obj?.c?.[0]let c3 = obj?.c?.c2?.() 展开语法 123456789101112131415161718192021// 1、函数调用：test(...list1)// 2、字面量数组构造或字符串：console.log([...list1, &#x27;4&#x27;, ...&#x27;test&#x27;])console.log(...list1)console.log([...new Set(list1)])// &lt;Hello params=&#123;...params&#125;&gt;// 3、构造字面量对象时,进行克隆或者属性拷贝const obj1 = &#123; a: &#123; b: 1, c: undefined, d: function() &#123;&#125;, e: /^\\d&#123;1&#125;/ &#125;&#125;const obj2 = &#123; ...obj1&#125;const obj3 = Object.assign(&#123;&#125;, obj1)const obj4 = JSON.parse(JSON.stringify(obj1)) //&#123;&quot;a&quot;:&#123;&quot;b&quot;:1,&quot;e&quot;:&#123;&#125;&#125;&#125; requestAnimationFrame 屏幕刷新频率：屏幕每秒出现图像的次数。普通笔记本为60Hz 动画原理：计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。 setTimeout：通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是： settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚； settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。 requestAnimationFrame的优势： 由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿 CPU节能，当页面被隐藏或最小化时，setTimeout 仍然在后台执行，requestAnimationFrame会停止渲染 12345678910111213141516171819202122232425262728293031myAnimation(&#123; target, time, inAnimation, afterAnimation&#125;) &#123; let aniId = null let currentNo = 0 const startTime = new Date().getTime() const p = (time * time) / target const render = () =&gt; &#123; const timeRange = new Date().getTime() - startTime; currentNo = timeRange * timeRange / p currentNo = currentNo &gt;= target ? target : currentNo if (inAnimation &amp;&amp; typeof inAnimation === &#x27;function&#x27;) &#123; inAnimation(currentNo) &#125; if (currentNo &lt; target) &#123; aniId = requestAnimationFrame(render) &#125; else &#123; cancelAnimationFrame(aniId) if (afterAnimation &amp;&amp; typeof afterAnimation === &#x27;function&#x27;) &#123; afterAnimation() &#125; &#125; &#125; aniId = requestAnimationFrame(render)&#125; 移动端自适应布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118;(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector(&#x27;meta[name=&quot;viewport&quot;]&#x27;); var flexibleEl = doc.querySelector(&#x27;meta[name=&quot;flexible&quot;]&#x27;); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; console.warn(&#x27;将根据已有的meta标签来设置缩放比例&#x27;); var match = metaEl.getAttribute(&#x27;content&#x27;).match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute(&#x27;content&#x27;); if (content) &#123; var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute(&#x27;data-dpr&#x27;, dpr); if (!metaEl) &#123; metaEl = doc.createElement(&#x27;meta&#x27;); metaEl.setAttribute(&#x27;name&#x27;, &#x27;viewport&#x27;); metaEl.setAttribute(&#x27;content&#x27;, &#x27;initial-scale=&#x27; + scale + &#x27;, maximum-scale=&#x27; + scale + &#x27;, minimum-scale=&#x27; + scale + &#x27;, user-scalable=no,viewport-fit=cover&#x27;); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement(&#x27;div&#x27;); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; console.log(metaEl) &#125; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 1080) &#123; width = 1080 * dpr; &#125; var rem = width / 10; docEl.style.fontSize = rem + &#x27;px&#x27;; flexible.rem = win.rem = rem; &#125; win.addEventListener(&#x27;resize&#x27;, function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener(&#x27;pageshow&#x27;, function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === &#x27;complete&#x27;) &#123; doc.body.style.fontSize = 12 * dpr + &#x27;px&#x27;; &#125; else &#123; doc.addEventListener(&#x27;DOMContentLoaded&#x27;, function(e) &#123; doc.body.style.fontSize = 12 * dpr + &#x27;px&#x27;; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === &#x27;string&#x27; &amp;&amp; d.match(/rem$/)) &#123; val += &#x27;px&#x27;; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === &#x27;string&#x27; &amp;&amp; d.match(/px$/)) &#123; val += &#x27;rem&#x27;; &#125; return val; &#125;&#125;)(window, window[&#x27;lib&#x27;] || (window[&#x27;lib&#x27;] = &#123;&#125;)); 创建postcss.config.js 1234567891011121314151617181920212223const autoprefixer = require(&#x27;autoprefixer&#x27;)const pxtorem = require(&#x27;postcss-pxtorem&#x27;)module.exports = (&#123; file&#125;) =&gt; &#123; let rootValue if (file?.dirname?.indexOf?.(&#x27;vant&#x27;) &gt; -1) &#123; rootValue = 37.5 &#125; else &#123; rootValue = 108 &#125; return &#123; plugins: [ autoprefixer(), pxtorem(&#123; rootValue: rootValue, propList: [&#x27;*&#x27;], minPixelValue: 2 &#125;) ] &#125;&#125; vw布局 持续集成（Continuous Integration）/.github/workflows/hexo-deploy.yml 1234567891011121314151617181920name: deploying Hexo project to GitHub pageson: push: branches: - master # master 分支有 push 行为时就触发这个 actionjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master - name: Build and Deploy uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action env: PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125; # secret 名 PUBLISH_REPOSITORY: chenshanshu/chenshanshu.github.io # 公共仓库，格式：GitHub 用户名/仓库名 BRANCH: gh-pages # 分支，填 gh-pages 就行 PUBLISH_DIR: ./public # 部署 public 目录下的文件 参考文献 mdn-运算符","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"js动画","slug":"js动画","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js%E5%8A%A8%E7%94%BB/"}]},{"title":"前端优化-图片懒加载","slug":"前端优化-图片懒加载","date":"2022-01-24T19:05:10.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/01/24/前端优化-图片懒加载/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/24/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"图片懒加载jquery插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556;(function ($, window) &#123; function Lazyload() &#123; this.$win = $(window) &#125; Lazyload.prototype = &#123; constructor: Lazyload, init: function () &#123; this.loadedLen = 0 this.getImgs() this.onScroll() this.$win.on(&quot;scroll&quot;, this.debounce(this.onScroll.bind(this))) &#125;, debounce: function (fn, wait) &#123; var first = true; var timer; var gapTime = wait || 50; return function () &#123; if (first) &#123; first = false fn.apply(this, arguments) &#125; else &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, gapTime) &#125; &#125; &#125;, getImgs: function () &#123; this.imgList = $.map($(&#x27;img[data-src]&#x27;).get(), function (i, index) &#123; return $(i) &#125;) &#125;, onScroll: function () &#123; if (this.loadedLen &gt;= this.imgList.length) return var wTop = this.$win.scrollTop(); var wHeight = this.$win.height(); var pageTop = wHeight + wTop $.each(this.imgList, function (index, img) &#123; if (img.loaded) return if (pageTop - img.offset().top +70 &gt; 0) &#123; img.attr(&#x27;src&#x27;, img.attr(&#x27;data-src&#x27;)) img.loaded = true this.loadedLen++ &#125; &#125;.bind(this)) &#125; &#125; $.fn.extend(&#123; lazyLoad: function () &#123; new Lazyload().init() &#125; &#125;)&#125;)(jQuery, window)","text":"图片懒加载jquery插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556;(function ($, window) &#123; function Lazyload() &#123; this.$win = $(window) &#125; Lazyload.prototype = &#123; constructor: Lazyload, init: function () &#123; this.loadedLen = 0 this.getImgs() this.onScroll() this.$win.on(&quot;scroll&quot;, this.debounce(this.onScroll.bind(this))) &#125;, debounce: function (fn, wait) &#123; var first = true; var timer; var gapTime = wait || 50; return function () &#123; if (first) &#123; first = false fn.apply(this, arguments) &#125; else &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, gapTime) &#125; &#125; &#125;, getImgs: function () &#123; this.imgList = $.map($(&#x27;img[data-src]&#x27;).get(), function (i, index) &#123; return $(i) &#125;) &#125;, onScroll: function () &#123; if (this.loadedLen &gt;= this.imgList.length) return var wTop = this.$win.scrollTop(); var wHeight = this.$win.height(); var pageTop = wHeight + wTop $.each(this.imgList, function (index, img) &#123; if (img.loaded) return if (pageTop - img.offset().top +70 &gt; 0) &#123; img.attr(&#x27;src&#x27;, img.attr(&#x27;data-src&#x27;)) img.loaded = true this.loadedLen++ &#125; &#125;.bind(this)) &#125; &#125; $.fn.extend(&#123; lazyLoad: function () &#123; new Lazyload().init() &#125; &#125;)&#125;)(jQuery, window) 使用IntersectionObserver实现懒加载","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"前端优化-缓存篇","slug":"前端优化-缓存篇","date":"2022-01-21T10:31:36.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/01/21/前端优化-缓存篇/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/21/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96-%E7%BC%93%E5%AD%98%E7%AF%87/","excerpt":"浏览器缓存属于必须掌握的内容，利用好缓存也是做性能优化的有效方法。 为什么要缓存 减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定比从服务器请求更快； 减少网络带宽消耗，降低运营成本； 减少对服务端的请求，降低服务器压力。 缓存读写顺序","text":"浏览器缓存属于必须掌握的内容，利用好缓存也是做性能优化的有效方法。 为什么要缓存 减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定比从服务器请求更快； 减少网络带宽消耗，降低运营成本； 减少对服务端的请求，降低服务器压力。 缓存读写顺序 HTTP缓存返回状态码200和304的区别浏览器缓存有两种：200 OK(from memory/disk cache)和304 Not Modified， 强缓存 协商缓存 缓存存放位置 本地浏览器 本地浏览器 http状态码 200 304 参数 PragmaCache-ControlExpires Etag/If-None-MatchLast-Modifined/If-Modified-Since Ctrl+F5强制刷新F5刷新地址栏回车页面链接跳转新开窗口前进、后退 无效无效有效有效有效有效 无效有效有效有效有效有效 200 OK(from memory/disk cache)这种缓存方式很普遍，大部分网站的静态文件都采用了，表示直接读取客户端缓存，无需再请求服务器。在服务器里设置，比如Nginx配置里会有类的配置： location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 30d;&#125;location ~ .*\\.(js|css)?$&#123;expires 12h;&#125; 这样就可以给静态文件缓存了，除非用户清除缓存或者强制刷新页面，否则会直接从客户端缓存里读取 304 Not Modified304缓存和上面最大的区别是浏览器要向服务器询问一次，如果服务器认为没有内容更新，直接返回304状态码，无需返回body内容，否则服务器返回新的资源 强缓存相关header字段 Expires策略 Expires 是Web服务器响应消息头字段，代表过期时间 Cache-control策略（重点关注）Cache-Control 与 Expires 的作用一致，都是指明当前资源的有效期，只不过 Cache-Control 的选项更多，若同时设置，优先级高于 Expires http协议头Cache-Control各指令及含义如下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息 。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 协商缓存相关的header字段 Last-Modifined/If-Modified-Since Last-Modified/If-Modified-Since要配合Cache-Control使用。 Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次像服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。 Etag/If-None-Match Etag：服务器响应时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304 参考文章 浏览器专题之缓存篇一文读懂http缓存（超详细）前端缓存详解","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"}]},{"title":"前端questions","slug":"前端-question","date":"2022-01-20T15:35:16.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/01/20/前端-question/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/20/%E5%89%8D%E7%AB%AF-question/","excerpt":"定义函数的两种方式123456789// （1）函数表达式var a = function() &#123; console.log(&#x27;函数表达式形式&#x27;)&#125;// （2）函数申明function a() &#123; console.log(&#x27;函数申明形式&#x27;)&#125;a() //函数表达式形式 两种方式的区别：函数申明会提升，可以在定义函数之前调用该函数","text":"定义函数的两种方式123456789// （1）函数表达式var a = function() &#123; console.log(&#x27;函数表达式形式&#x27;)&#125;// （2）函数申明function a() &#123; console.log(&#x27;函数申明形式&#x27;)&#125;a() //函数表达式形式 两种方式的区别：函数申明会提升，可以在定义函数之前调用该函数 1234567function f(x) &#123; console.log(x); var x = 200; console.log(x); &#125;f(a = 100);console.log(a); 浏览器渲染html步骤1、解析html:会按顺序解析，浏览器有专门的html解析器来解析HTML，并在解析的过程中构建DOM树2、构建dom树：它和步骤(1) 是同步进行，可以理解为边解析边构建。3、构建呈现树renderTree：将dom树与css结合，也就是将样式应用到dom节点上4、布局：计算呈现树节点的大小和位置，这一位置是递归进行的。5、绘制：布局完成后，便是将呈现树绘制出来显示在屏幕上。 什么是回流和重绘pc端问题不大，移动端会导致页面卡顿 回流 reflow:当呈现树renderTree中的一部分或全部因为尺寸、布局、隐藏等改变改重新构建，称之为回流。 重绘：当呈现树renderTree中的一部分元素需要更新属性，而属性只会影响外观、风格而不影响布局，比如颜色、字体大小等，则称之为重绘。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"js事件模型","slug":"js事件模型","date":"2022-01-19T15:07:06.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/01/19/js事件模型/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/19/js%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/","excerpt":"DOM0级事件模型 DOM0级事件模型是早期事件模型，实现代码如下： 1234&lt;button id=&quot;btn&quot;&gt;&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&#x27;btn&#x27;).onclick = function()&#123;&#125;&lt;/script&gt; 特点： 直接在DOM 对象上注册事件 注册多个时后面的事件会覆盖之前的 所有浏览器都兼容 清除事件时直接赋值null DOM2级事件模型标准事件模型事件传播过程1. 事件捕获：事件由`document`一直向下捕捉到目标元素 2. 事件执行：目标对象的事件处理程序执行 3. 事件冒泡：事件从目标元素上升到`document` 所有时间类型都会经历第一阶段，有的事件不会经历第三阶段（submit），一个 DOM 对象可以注册多个相同类型的事件，不会发生覆盖。 事件注册1[object].addEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) 解除事件1[object].removeEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) true/false决定在那个阶段调用函数true: 捕获false: 冒泡 事件对象 停止传播：event.stopPropagation() 阻止默认动作：event.preventDefault() 示例 给一个元素添加两个事件，捕获阶段的事件会先执行，但两个时间戳相同。 1234567var btn = document.getElementById(&#x27;btn__submit&#x27;)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in bubble&#x27;, new Date().getTime())&#125;, false)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in capture&#x27;, new Date().getTime())&#125;, true) 绑定多个事件，并阻止冒泡12345678910btn.addEventListener(&#x27;click&#x27;,function(params) &#123; params.stopPropagation() console.log(1)&#125;,false)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(2)&#125;,true)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(3)&#125;,true) 在冒泡阶段阻止冒泡，在捕获阶段的绑定事件会先执行，三个事件都会触发在捕获阶段阻止冒泡，第一个事件不再触发，后两个触发。","text":"DOM0级事件模型 DOM0级事件模型是早期事件模型，实现代码如下： 1234&lt;button id=&quot;btn&quot;&gt;&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&#x27;btn&#x27;).onclick = function()&#123;&#125;&lt;/script&gt; 特点： 直接在DOM 对象上注册事件 注册多个时后面的事件会覆盖之前的 所有浏览器都兼容 清除事件时直接赋值null DOM2级事件模型标准事件模型事件传播过程1. 事件捕获：事件由`document`一直向下捕捉到目标元素 2. 事件执行：目标对象的事件处理程序执行 3. 事件冒泡：事件从目标元素上升到`document` 所有时间类型都会经历第一阶段，有的事件不会经历第三阶段（submit），一个 DOM 对象可以注册多个相同类型的事件，不会发生覆盖。 事件注册1[object].addEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) 解除事件1[object].removeEventListener(&#x27;事件名称&#x27;，方法名（函数），事件模型（true/false）) true/false决定在那个阶段调用函数true: 捕获false: 冒泡 事件对象 停止传播：event.stopPropagation() 阻止默认动作：event.preventDefault() 示例 给一个元素添加两个事件，捕获阶段的事件会先执行，但两个时间戳相同。 1234567var btn = document.getElementById(&#x27;btn__submit&#x27;)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in bubble&#x27;, new Date().getTime())&#125;, false)btn.addEventListener(&#x27;click&#x27;, function(params) &#123; console.log(&#x27;in capture&#x27;, new Date().getTime())&#125;, true) 绑定多个事件，并阻止冒泡12345678910btn.addEventListener(&#x27;click&#x27;,function(params) &#123; params.stopPropagation() console.log(1)&#125;,false)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(2)&#125;,true)btn.addEventListener(&#x27;click&#x27;,function(params) &#123; console.log(3)&#125;,true) 在冒泡阶段阻止冒泡，在捕获阶段的绑定事件会先执行，三个事件都会触发在捕获阶段阻止冒泡，第一个事件不再触发，后两个触发。 IE模型 IE的事件机制没有捕获阶段，事件流是非标准的，只有目标阶段和冒泡阶段。 添加事件：dom.attachEvent() 移除事件：dom.detachEvent() 阻止冒泡：12e = window.event;e.cancelBubble = true; 阻止默认事件1e.returnValue = false; 标准事件模型中，注册函数时，事件类型前不加on,IE中要加on attachEvent注册的函数为全局调用函数，而不是文档元素的方法，因此this引用的是window对象 注册多个处理函数时，标准事件模型中，若注册多个同名函数会被忽略，以第一个为准；在IE中，同一个函数可以被注册多次 DOM3级事件DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下： UI事件，当用户与页面上的元素交互时触发，如：load、scroll、abort、select、error 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 同时DOM3级事件也允许使用者自定义一些事件。 UI事件在DOM2级事件中归为HTML事件，判断浏览器是否支持DOM2级别事件中的HTML事件 1var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;,&quot;2.0&quot;) 判断浏览器是否支持DOM3级事件规定的UI事件： 1var isSupported = document.implementation.hasFeature(&quot;UIEvents&quot;,&quot;3.0&quot;) 自定义事件（Event和CustomEvent） Event Event算是一个顶级接口，CustomEvent基于Event,增加了部分参数 1var event = new Event(typeArg[, eventInit]); eventInit: 参数 介绍 bubbles 可选，Boolean类型，默认值为 false，表示该事件是否冒泡。 cancelable 可选，Boolean类型，默认值为 false， 表示该事件能否被取消。 composed 可选，Boolean类型，默认值为 false，指示事件是否会在影子DOM根节点之外触发侦听器。 example: 12345var evt = new Event(&quot;test&quot;, &#123;&quot;bubbles&quot;:true, &quot;cancelable&quot;:false&#125;);document.addEventListener(&#x27;test&#x27;, function () &#123; console.log(&#x27;触发了自定义事件&#x27;)&#125;)document.dispatchEvent(evt); CustomEvent1var event = new CustomEvent(typeArg,customEventInit); customEventInit: 参数 介绍 detail 可选的默认值是 null 的任意类型数据，是一个与 event 相关的值（向事件对象添加更多数据） customEventInit可以接受eventInit字典的参数 以上内容参考了下列文章CSDN:事件模型","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"GithubAction和Webhook使用入门","slug":"GithubAction和Webhook使用入门","date":"2022-01-11T11:12:42.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2022/01/11/GithubAction和Webhook使用入门/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2022/01/11/GithubAction%E5%92%8CWebhook%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","excerpt":"什么是Github Action Github Action是Github官方推出的持续集成/部署模块服务(CI/CD)。 它是事件驱动的，而且与Github深度整合，可以运行很多Github事件，除了部署和发布，还可以做很多事情，例如压缩合并css和JavaScript。 什么是Webhook Webhook是一个API概念，术语“网络钩子”，有时也被称为“反向 API”。因为它提供了API规则，Webhook将向你的应用发起http请求。 准确的说Webhook是一种web回调或者http的push API，可以使用Webhook“订阅”活动。 hexo自动打包发布通知流程 本地编写完，通过git提交到Github仓库 Github Action监听到push event事件触发ci.yml执行脚本 build打包生成部署文件推送到目标仓库 设置webhook监听推送事件，执行webhook.sh脚本 将结果进行邮件通知 实现步骤第一步，在github setting-&gt;Developer settings-&gt;Personal access tokens创建新的token，并保存这个值；第二步，进入源代码仓库，Settings-&gt;Secrets里将第一步的token添加进去，SECRET_NAME取名为HEXO_DEPLOY；第三步，新建一个Github仓库，命名为用户名.github.io,启动github-pages,具体可参考官方文档；","text":"什么是Github Action Github Action是Github官方推出的持续集成/部署模块服务(CI/CD)。 它是事件驱动的，而且与Github深度整合，可以运行很多Github事件，除了部署和发布，还可以做很多事情，例如压缩合并css和JavaScript。 什么是Webhook Webhook是一个API概念，术语“网络钩子”，有时也被称为“反向 API”。因为它提供了API规则，Webhook将向你的应用发起http请求。 准确的说Webhook是一种web回调或者http的push API，可以使用Webhook“订阅”活动。 hexo自动打包发布通知流程 本地编写完，通过git提交到Github仓库 Github Action监听到push event事件触发ci.yml执行脚本 build打包生成部署文件推送到目标仓库 设置webhook监听推送事件，执行webhook.sh脚本 将结果进行邮件通知 实现步骤第一步，在github setting-&gt;Developer settings-&gt;Personal access tokens创建新的token，并保存这个值；第二步，进入源代码仓库，Settings-&gt;Secrets里将第一步的token添加进去，SECRET_NAME取名为HEXO_DEPLOY；第三步，新建一个Github仓库，命名为用户名.github.io,启动github-pages,具体可参考官方文档；","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"}]},{"title":"前端分享 2021/12/31","slug":"前端分享-2021-12-31","date":"2021-12-31T10:16:25.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2021/12/31/前端分享-2021-12-31/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/12/31/%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB-2021-12-31/","excerpt":"reduce()的用法1arr.reduce(callback,[initialValue]) 数组求和 12345var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; return prev + cur; &#125;, 0) 计算一个数组中每个元素出现的次数 123456789let arr = [&#x27;test&#x27;, &#x27;test&#x27;, &#x27;name&#x27;, &#x27;sun&#x27;, &#x27;mon&#x27;, &#x27;wen&#x27;, &#x27;sun&#x27;]let result = arr.reduce((pre, cur) =&gt; &#123; if (cur in pre) &#123; pre[cur]++ &#125; else &#123; pre[cur] = 1 &#125; return pre&#125;, &#123;&#125;) 数组去重 12345let result = arr.reduce((pre, cur) =&gt; &#123; if (!pre.includes(cur)) &#123; pre.push(cur) &#125;&#125;, []) 将多维数组转为一维 123456789let arr = [ [0, 1], [2, 3], [4, [5, 6, 7]]]const newArr = function(arr) &#123; return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])&#125;console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]","text":"reduce()的用法1arr.reduce(callback,[initialValue]) 数组求和 12345var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; return prev + cur; &#125;, 0) 计算一个数组中每个元素出现的次数 123456789let arr = [&#x27;test&#x27;, &#x27;test&#x27;, &#x27;name&#x27;, &#x27;sun&#x27;, &#x27;mon&#x27;, &#x27;wen&#x27;, &#x27;sun&#x27;]let result = arr.reduce((pre, cur) =&gt; &#123; if (cur in pre) &#123; pre[cur]++ &#125; else &#123; pre[cur] = 1 &#125; return pre&#125;, &#123;&#125;) 数组去重 12345let result = arr.reduce((pre, cur) =&gt; &#123; if (!pre.includes(cur)) &#123; pre.push(cur) &#125;&#125;, []) 将多维数组转为一维 123456789let arr = [ [0, 1], [2, 3], [4, [5, 6, 7]]]const newArr = function(arr) &#123; return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])&#125;console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7] Vuex数据保存问题 Vuex存储在内存，数据刷新就会丢失，无内存大小限制，而Storage最大为5M。数据为响应式，用于组件间传值。 sessionStorage 用于临时保存数据，标签页关闭后数据删除 localStorage 可以在多个标签页共享没有过期时间，除非手动删除 question: 移动端页面进行支付时页面会进行刷新, 导致Vuex存储的数据丢失了。 12345678910111213141516171819202122232425const getState = _ =&gt; JSON.parse(window.sessionStorage.getItem(&quot;state&quot;) || &#x27;&#123;&#125;&#x27;)const setState = state =&gt; window.sessionStorage.setItem(&#x27;state&#x27;, JSON.stringify(state || &#123;&#125;));import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; id: null, name: null, ...getState() &#125; mutations: &#123; SETNAME(state, v) &#123; state.name = v &#125; &#125;, actions: &#123; setName(context, val) &#123; context.commit(&quot;SETNAME&quot;, val) setState(context.state) &#125; &#125;, getters: &#123;&#125;&#125;) scrollHeight用法","categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"reduce","slug":"reduce","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/reduce/"},{"name":"vuex","slug":"vuex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vuex/"}]},{"title":"flask-auth","slug":"flask-auth","date":"2021-10-19T15:41:16.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2021/10/19/flask-auth/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/10/19/flask-auth/","excerpt":"一、windows系统python3虚拟环境 新建文件夹venv，然后执行python -m venv venv 运行.\\Scripts\\activate.bat启动虚拟环境cmd中需要使用反斜线，否则无法启动 二、Flask服务12345678910111213141516171819202122from flask import Flask,requestfrom markupsafe import escapeapp = Flask(__name__)#通过route()装饰器来把函数绑定到URL@app.route(&quot;/&quot;)def index(): return &quot;hellow world&quot;#app对象的add_url_rule()函数也可以用于将URL与函数绑定def hello_world(): return &#x27;hello world&#x27;app.add_url_rule(&#x27;/&#x27;,&#x27;hello&#x27;,hello_word)@app.route(&quot;/path/&lt;path:subpath&gt;&quot;)def show_subpath(subpath): return f&#x27;subpath &#123;escape(subpath)&#125;&#x27;if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000) 转换器类型：URL内用中括号标记变量，通过converter:variable_name为变量加上转换器 字段 说明 string （缺省值）接受任何不包含斜杆的文本 int 接受正整数 float 接受正浮点数 path 类似 string ，但可以包含斜杠 uuid 接受 UUID 字符串 URL构建url_for()函数用于构建指定函数的URL, 函数名称作为第一个参数，可接受任意个关键字参数 静态文件只要在您的包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) 三、Flask服务启动 安装Flask模块pip install Flask 编写好脚本保存为server.py set FLASK_APP=server 需要打开开发功能set FLASK_ENV=development 运行flask run","text":"一、windows系统python3虚拟环境 新建文件夹venv，然后执行python -m venv venv 运行.\\Scripts\\activate.bat启动虚拟环境cmd中需要使用反斜线，否则无法启动 二、Flask服务12345678910111213141516171819202122from flask import Flask,requestfrom markupsafe import escapeapp = Flask(__name__)#通过route()装饰器来把函数绑定到URL@app.route(&quot;/&quot;)def index(): return &quot;hellow world&quot;#app对象的add_url_rule()函数也可以用于将URL与函数绑定def hello_world(): return &#x27;hello world&#x27;app.add_url_rule(&#x27;/&#x27;,&#x27;hello&#x27;,hello_word)@app.route(&quot;/path/&lt;path:subpath&gt;&quot;)def show_subpath(subpath): return f&#x27;subpath &#123;escape(subpath)&#125;&#x27;if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000) 转换器类型：URL内用中括号标记变量，通过converter:variable_name为变量加上转换器 字段 说明 string （缺省值）接受任何不包含斜杆的文本 int 接受正整数 float 接受正浮点数 path 类似 string ，但可以包含斜杠 uuid 接受 UUID 字符串 URL构建url_for()函数用于构建指定函数的URL, 函数名称作为第一个参数，可接受任意个关键字参数 静态文件只要在您的包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。 url_for(&#39;static&#39;, filename=&#39;style.css&#39;) 三、Flask服务启动 安装Flask模块pip install Flask 编写好脚本保存为server.py set FLASK_APP=server 需要打开开发功能set FLASK_ENV=development 运行flask run 四、更多用法4.1、日志调用示例： 123app.logger.debug(&#x27;A value for debugging&#x27;)app.logger.warning(&#x27;A warning occurred (%d apples)&#x27;, 42)app.logger.error(&#x27;An error occurred&#x27;) 4.2、Flask概述什么是Web Framework?Web Application Framework(web应用程序框架)或简单的Web Framework(Web框架)表示一个库和模块的集合，使Web应用程序开发人员能够编写应用程序，而不必担心协议，线程管理等低级细节。 什么是Flask?Flask是一个用Python编写的Web应用程序框架。Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。 WSGIWeb Server Gateway Interface(Web服务器网关接口，WSGI)已被用作Python Web应用程序开发的标准。WSGI是Web服务器和Web应用程序之间通用接口的规范 Werkzeug它是一个WSGI工具包，它实现了请求，响应对象和实用函数。这使得能够在其上构建Web框架。 jinja2jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。","categories":[{"name":"python","slug":"python","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/python/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/flask/"},{"name":"Oauth","slug":"Oauth","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Oauth/"}]},{"title":"css整理","slug":"css整理","date":"2021-07-28T16:16:10.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2021/07/28/css整理/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/07/28/css%E6%95%B4%E7%90%86/","excerpt":"sticky商品详情页，主图缓动效果 1234position: sticky;top: 0;transform: translateZ(-1px) scale(2);transform-origin: 0 0;","text":"sticky商品详情页，主图缓动效果 1234position: sticky;top: 0;transform: translateZ(-1px) scale(2);transform-origin: 0 0;","categories":[{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/css/"}]},{"title":"一种避免重复请求的方法","slug":"一种避免重复请求的方法","date":"2021-06-21T19:44:50.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2021/06/21/一种避免重复请求的方法/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/06/21/%E4%B8%80%E7%A7%8D%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"需求1、需求：小程序在app.js中需要发起一个login请求，在index的onLoad()钩子里要拿到login的返回值进行后续操作。2、通过该方法可以避免在第一次请求未完成时发出第二个请求。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 一种避免重复请求的方法,不支持async * @arg * arg[0] id String * arg[1] promise函数 Function * arg[2] arg[1]的参数 Object **/let emiter = &#123;&#125;;export default class Emiter &#123; constructor(...arg) &#123; const unionKey = &#x27;emiter-&#x27; + arg[0] this.emiter = emiter[unionKey] = emiter[unionKey] || &#123; resolveQueue: [], rejectQueue: [] &#125; this.methods = arg[1] || &#x27;&#x27; if (typeof this.methods !== &#x27;function&#x27;) return if (this.emiter.promiseStatus === &#x27;resolved&#x27;) &#123; setTimeout(_ =&gt; &#123; this.emitAll(this.emiter.resolveQueue, this.emiter.res) &#125;) &#125; else if (!this.emiter.promiseStatus) &#123; this.emiter.promiseStatus = &#x27;pending&#x27; this.methods(arg[2] || &#123;&#125;).then(res =&gt; &#123; setTimeout(_ =&gt; &#123; delete this.emiter.promiseStatus &#125;, 1000) this.emiter.promiseStatus = &#x27;resolved&#x27; this.emiter.res = res this.emitAll(this.emiter.resolveQueue, res) &#125;).catch(err =&gt; &#123; delete this.emiter.promiseStatus this.emitAll(this.emiter.rejectQueue, err) &#125;) &#125; &#125; emitAll(queue, res) &#123; if (this.emiter.promiseStatus === &#x27;pending&#x27;) return while (queue.length) &#123; queue[0](res) queue.shift() &#125; &#125; then(callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.resolveQueue.push(callback) &#125; return this &#125; catch (callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.rejectQueue.push(callback) &#125; return this &#125;&#125;","text":"需求1、需求：小程序在app.js中需要发起一个login请求，在index的onLoad()钩子里要拿到login的返回值进行后续操作。2、通过该方法可以避免在第一次请求未完成时发出第二个请求。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 一种避免重复请求的方法,不支持async * @arg * arg[0] id String * arg[1] promise函数 Function * arg[2] arg[1]的参数 Object **/let emiter = &#123;&#125;;export default class Emiter &#123; constructor(...arg) &#123; const unionKey = &#x27;emiter-&#x27; + arg[0] this.emiter = emiter[unionKey] = emiter[unionKey] || &#123; resolveQueue: [], rejectQueue: [] &#125; this.methods = arg[1] || &#x27;&#x27; if (typeof this.methods !== &#x27;function&#x27;) return if (this.emiter.promiseStatus === &#x27;resolved&#x27;) &#123; setTimeout(_ =&gt; &#123; this.emitAll(this.emiter.resolveQueue, this.emiter.res) &#125;) &#125; else if (!this.emiter.promiseStatus) &#123; this.emiter.promiseStatus = &#x27;pending&#x27; this.methods(arg[2] || &#123;&#125;).then(res =&gt; &#123; setTimeout(_ =&gt; &#123; delete this.emiter.promiseStatus &#125;, 1000) this.emiter.promiseStatus = &#x27;resolved&#x27; this.emiter.res = res this.emitAll(this.emiter.resolveQueue, res) &#125;).catch(err =&gt; &#123; delete this.emiter.promiseStatus this.emitAll(this.emiter.rejectQueue, err) &#125;) &#125; &#125; emitAll(queue, res) &#123; if (this.emiter.promiseStatus === &#x27;pending&#x27;) return while (queue.length) &#123; queue[0](res) queue.shift() &#125; &#125; then(callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.resolveQueue.push(callback) &#125; return this &#125; catch (callback) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; this.emiter.rejectQueue.push(callback) &#125; return this &#125;&#125; 示例1234567const fun = function (params) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(_ =&gt; &#123; resolve(&#x27;REQUEST SUCCESS&#x27;) &#125;, 1000) &#125;)&#125;new Emiter(&#x27;union-id&#x27;, fun).then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"浏览器下载文件","slug":"浏览器下载文件","date":"2021-04-23T15:17:35.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2021/04/23/浏览器下载文件/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/04/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/","excerpt":"","text":"文件下载","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"浏览器打印功能","slug":"浏览器打印功能","date":"2021-04-07T10:22:41.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2021/04/07/浏览器打印功能/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2021/04/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD/","excerpt":"打印API：window.print() 需求：打印局部内容，如打印下面页面类名 printBox 里面的内容12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div&gt;页面内容...&lt;/div&gt; &lt;button class=&quot;printBtn&quot;&gt;打印报告&lt;/button&gt; &lt;div id=&quot;printContent&quot; style=&quot;display:none&quot;&gt; &lt;div class=&quot;printBox&quot;&gt; &lt;h1&gt;打印报告&lt;h1&gt; &lt;p&gt;报告内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","text":"打印API：window.print() 需求：打印局部内容，如打印下面页面类名 printBox 里面的内容12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div&gt;页面内容...&lt;/div&gt; &lt;button class=&quot;printBtn&quot;&gt;打印报告&lt;/button&gt; &lt;div id=&quot;printContent&quot; style=&quot;display:none&quot;&gt; &lt;div class=&quot;printBox&quot;&gt; &lt;h1&gt;打印报告&lt;h1&gt; &lt;p&gt;报告内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 实现：已知A4纸张尺寸为297mm*210mm，通过创建 iframe 来实现打印；123456789101112131415161718192021222324252627282930var a = 1;var frameId = &#x27;printFrame&#x27;;/** * @param &#123;boolean&#125; portrait 是否纵向打印*/var print = function(portrait)&#123; var iframe = document.getElementById(frameId); if(!iframe)&#123; var frameStyle = portrait ? `&lt;style&gt;@page&#123;size:A4 portrait;margin:0mm;width:297mm;min-height:200mm;&#125;&lt;/style&gt;`: `&lt;style&gt;@page&#123;size:A4 landscape;margin:0mm;width:210mm;min-height:280mm;&#125;&lt;/style&gt;`; // 当高度设置为最大值，会出现打印内容后面多出一张空白页 var el = document.getElementById(&quot;printContent&quot;); iframe = document.createElement(&#x27;IFRAME&#x27;); iframe.setAttribute(frameId); iframe.setAttribute(&#x27;style&#x27;, &#x27;position:absolute;width:0px;height:0px;left:-500px;top:-500px;&#x27;); document.body.appendChild(iframe); var doc = iframe.contentWindow.document; doc.write(frameStyle); doc.write(`&lt;div&gt;$&#123;el.innerHTML&#125;&lt;/div&gt;`); doc.close(); iframe.contentWindow.focus(); &#125; iframe.contentWindow.print(); if (navigator.userAgent.indexOf(&quot;MSIE&quot;) &gt; 0)&#123; document.body.removeChild(iframe); &#125;&#125; 注意： 当打印内容带有背景时候记得勾选背景图形选项 此处只测试了Chrome，兼容性未处理 扩展：打印机型号不同时打印内容也有差别，所以可以通过用canvas来绘制内容(可以参考微信小程序生成分享图功能)，然后生成图片放入第二步的iframe中。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"Web Components","slug":"web-components","date":"2020-11-06T10:10:29.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/11/06/web-components/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/11/06/web-components/","excerpt":"","text":"The Shadow DOM通过shadow DOM在文档流中创建一些完全独立于其他元素的子DOM树（sub-DOM trees），由于这个特性，使我们能封装一个具有独立功能的组件，并且可以保证不会干扰到其它DOM元素 兼容性Chrome、Opera、Chrome for Android WebComponents的重要性 开发无害插件（主页面样式不会修改组件样式） 能开发更通用的组件 可维护","categories":[{"name":"html5","slug":"html5","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/html5/"}],"tags":[{"name":"web","slug":"web","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/web/"}]},{"title":"Apache配置","slug":"Apache配置","date":"2020-10-28T15:40:04.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/10/28/Apache配置/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/Apache%E9%85%8D%E7%BD%AE/","excerpt":"","text":"wamp安装及配置反向代理 安装wamp，也可安装apache 下载地址 “http://www.wampserver.com/en/&quot; 配置apache使外网访问（版本2.4.27） 修改httpd.conf文件Require all denied ==&gt; Require all granted Require local ==&gt; Require all granted Listen 0.0.0.0:8000 //搜索 Listen 0.0.0.0:80 添加对8000端口的监听 修改httpd-vhosts.conf文件Require all denied ==&gt; Require all granted //至此别人可以访问你的www目录下的静态内容 设置花生壳内网穿透（有公网ip的忽略） 填写你的局域网ip,端口,获得外网访问地址 配置Apache反向代理nodejs服务 修改httpd.conf文件 //去掉下列内容的注释，引入代理模块 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so //如需ftp，取消如下注释 LoadModule proxy_ftp_module modules/mod_proxy_ftp.so 修改httpd-vhosts.conf文件 //添加下列代码 &lt;VirtualHost *:8000&gt; //不放在80端口上防止影响phpMyAdmin ServerName 20xr498049.imwork.net //外网访问的域名 ServerAlias www.20xr498049.imwork.net:42685 //别名 #DocumentRoot &quot;$&#123;INSTALL_DIR&#125;/www&quot; &lt;Proxy *&gt; Order allow,deny Allow from all &lt;/Proxy&gt; &lt;Location /&gt; ProxyPass http://localhost:3000/ //node访问地址 ProxyPassReverse http://localhost:3000/ &lt;/Location&gt; &lt;/VirtualHost&gt; 开启nodejs项目，重启apache服务。","categories":[],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Apache/"}]},{"title":"git 手册","slug":"git-手册","date":"2020-10-28T15:34:41.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/10/28/git-手册/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/git-%E6%89%8B%E5%86%8C/","excerpt":"git操作 分支操作 操作 命令 新建本地新分支 git branch branch 新建并切换到本地新分支 git checkout -b branch 新建远程分支 git push origin branch:remoteBranch 删除本地分支 git branch -d dev 删除远程分支 git push origin :remoteBranch 设置本地追踪远程分支 git branch --set-upstream-to=origin/remoteBranch localBranch 直接将远程分支拉取并在本地建立关联分支 git checkout -b localBranch origin/remoteBranch orgit fetch origin master:test 强制操作 操作 命令 强制覆盖本地修改 git fetch --allgit reset --hard origin/mastergit pull 强制上传 git push -f origin remoteBranch 版本管理 操作 命令 查看本地分支与远程关联情况 git branch -vv 查看本地仓库状态 git status 查看本地操作 git reflog 比较本地与远程 git log -p master ..origin/master 查看某个提交 git show commitID 修改主机地址 git remote set-url origin ssh.aaaa.gitorgit remote rm origingit remote add origin [url] 版本回退 git reset --hard commitID 版本回滚 git revert HEAD 将指定的提交（commit）应用于其他分支 git cherry-pick commitID//分支名 Cherry pick 支持一次转移多个提交 git cherry-pick A^..B//包含A和B","text":"git操作 分支操作 操作 命令 新建本地新分支 git branch branch 新建并切换到本地新分支 git checkout -b branch 新建远程分支 git push origin branch:remoteBranch 删除本地分支 git branch -d dev 删除远程分支 git push origin :remoteBranch 设置本地追踪远程分支 git branch --set-upstream-to=origin/remoteBranch localBranch 直接将远程分支拉取并在本地建立关联分支 git checkout -b localBranch origin/remoteBranch orgit fetch origin master:test 强制操作 操作 命令 强制覆盖本地修改 git fetch --allgit reset --hard origin/mastergit pull 强制上传 git push -f origin remoteBranch 版本管理 操作 命令 查看本地分支与远程关联情况 git branch -vv 查看本地仓库状态 git status 查看本地操作 git reflog 比较本地与远程 git log -p master ..origin/master 查看某个提交 git show commitID 修改主机地址 git remote set-url origin ssh.aaaa.gitorgit remote rm origingit remote add origin [url] 版本回退 git reset --hard commitID 版本回滚 git revert HEAD 将指定的提交（commit）应用于其他分支 git cherry-pick commitID//分支名 Cherry pick 支持一次转移多个提交 git cherry-pick A^..B//包含A和B","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"}]},{"title":"linux 笔记","slug":"linux-shell笔记","date":"2020-10-28T15:28:10.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/10/28/linux-shell笔记/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/linux-shell%E7%AC%94%E8%AE%B0/","excerpt":"几个常用命令","text":"几个常用命令 raspberry 安装nginx sudo apt-get install nginx sudo /etc/init.d/nginx start 启动 curl -I localhost:80 测试能否访问 sudo nano /etc/nginx/sites-available/default 修改端口 sudo /etc/init.d/nginx reload 重启 用户操作 useradd chenss 添加用户 userdel chenss 删除用户 usermod -a -G user chenss 添加用户组 usermod -g user chenss 修改用户主组 newgrp root 切换用户主从组 groupadd groupname 添加组 groupmod -n new_name： 修改组名 groupdel groupname 删除组 groupmems -g groupname [action] /* -a, –add username: 指定用户加入组；-d, –delete username: 从组中删除用户；-p, –purge : 从组中清除所有成员；-l, –list: 显示组成员列表; */ gpasswd -a chenss user 给组添加用户 gpasswd -d chenss user 删除组中用户 主要配置文件 /etc/passwd: 用户及其属性信息(名称，UID, 主组ID) /etc/shadow: 用户密码及相关属性。 /etc/group: 组及其属性信息。 /etc/gshadow: 组密码及相关属性。 /etc/wpa_supplicant/wpa_supplicant.conf: WiFi管理 redesktop使用文档 apt-get install redesktop ctrl+alt+t //打开终端 rdesktop -f -a 32 -u username -p password ip:port //-f 全屏 ctrl+alt+enter //切换全屏 ctrl+alt+F2 //进入字符终端杀死进程 sudo pkill rdesktop","categories":[{"name":"linux","slug":"linux","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/shell/"}]},{"title":"快速上手webpack","slug":"快速上手webpack","date":"2020-10-28T15:25:23.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/10/28/快速上手webpack/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bwebpack/","excerpt":"","text":"概念 webpack是一个前端资源加载/打包工具。 它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 安装需要先安装好nodejs, 然后执行下列操作；可能遇到的问题，linux下通过sudo获得管理员权限安装，windows下开始搜索cmd, 右键以管理员身份运行才能安装以下内容；但是在vscode、webstorm等控制台可以直接安装。 mkdir webpacktest cd webpacktest npm init -f-y npm i webpack -D /*i == install ; -D == --dev--save ; */ npm i webpack-cli -D /*webpack4提示需要安装这个才能使用*/ 使用安装后webpack模块就被安装到项目里的node_modules文件夹下面；新建文件demo1.js，写入你想执行的js代码。 网上大部分教程都是在linux下的执行命令，这里讲一下windows下的使用方法。 .\\node_modules\\.bin\\webpack demo1.js -o bundle.js --mode development 至此完成了第一次的代码打包。 使用配置文件在项目根目录下新建webpack.config.js；新建src文件夹，以后自己编写的代码全部放在这个文件夹下面；新建dist文件夹用来存放打包后的文件。 const path = require('path'); const config = &#123; mode:'development', entry:&#123; main:path.resolve(__dirname,\"./src\",\"index.js\") &#125;, output:&#123; path:path.resolve(__dirname,'dist'), filename:'bundle.js' &#125;, module:&#123; rules:[ &#123; test:/\\.css$/, use:[ \"style-loader\", \"css-loader\" ] &#125; ] &#125; &#125;; module.exports = config; 有了配置文件后可以用以下命令就能执行打包了 .\\node_modules\\.bin\\webpack 使用起来还是不方便，可以把命令加到package.json里；注意这里只需要提供包名，node会自动找到包所在目录。 \"scripts\": &#123; \"start\": \"webpack\", &#125; 现在可以在命令行使用下面命令打包 npm start /*注意，当命令指定的为start时候可以省去run*/ markdown预览 ctrl+shift+v","categories":[{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/webpack/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-10-28T10:58:34.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/10/28/正则表达式/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/10/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"^((?!\\d*$)\\S{2, })|(\\d{6, })$//超过2个字符或者超过6位纯数字 匹配某个变量123var ch = &#x27;变量&#x27;eval(`/$&#123;ch&#125;/g`)new RegExp(ch,&#x27;g&#x27;)","categories":[{"name":"regex","slug":"regex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/regex/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"vue组件的三种调用方式","slug":"vue组件的三种调用方式","date":"2020-06-04T15:37:56.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/06/04/vue组件的三种调用方式/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/06/04/vue%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、注册组件，直接调用这种比较常见 1234567891011121314&lt;template&gt; &lt;div class=&quot;page&quot;&gt; &lt;my-dialog /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import MyDialog from &#x27;@/components&#x27; export default &#123; components: &#123; &#x27;my-dialog&#x27;: MyDialog &#125; &#125;&lt;/script&gt; 二、通过js调用使用场景：登陆弹窗，付费弹窗 123456789101112131415161718192021222324252627282930313233343536373839import VipPop from &#x27;./VipPop&#x27;class VipPopup &#123; constructor(Vue, options) &#123; this.vipPop = Vue.extend(VipPop); this.popupInstance = new this.vipPop(&#123; data() &#123; return &#123; title: &#x27;成为VIP，开启新特权&#x27; &#125; &#125;, propsData: &#123;&#125;, extends: options &#125;).$mount(); &#125; show(obj) &#123; obj.title &amp;&amp; (this.popupInstance.title = obj.title); if (this.el) &#123; this.el.style.display = &#x27;block&#x27;; &#125; else &#123; this.el = this.popupInstance.$el; document.body.appendChild(this.el) &#125; document.body.classList.add(&#x27;van-overflow-hidden&#x27;) &#125; hide() &#123; document.body.classList.remove(&#x27;van-overflow-hidden&#x27;) this.el &amp;&amp; (this.el.style.display = &#x27;none&#x27;); &#125; remove() &#123; document.body.classList.remove(&#x27;van-overflow-hidden&#x27;) this.el &amp;&amp; this.el.remove(); this.el = null; &#125; export default &#123; install: function(Vue, options) &#123; Vue.prototype.$vipPop = new VipPopup(Vue, options); &#125; &#125;;&#125; 1234.van-overflow-hidden &#123; overflow: hidden !important; /**禁止背景滚动条**/&#125; 在main.js中引入这个组件 12345678import Vue from &#x27;vue&#x27;import router from &quot;./router.js&quot;import store from &#x27;./store&#x27;import VipPop from &#x27;@/components/VipPop&#x27;Vue.use(VipPop, &#123; router, store&#125;) 三、以指令的形式调用使用场景：加载动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import Vue from &#x27;vue&#x27;const LoadingConstructor = Vue.extend(require(&#x27;./Loading.vue&#x27;))export default &#123; install: Vue =&gt; &#123; Vue.directive(&#x27;loading&#x27;, &#123; // 指令的关键 bind: (el, binding) =&gt; &#123; const loading = new LoadingConstructor(&#123; // 实例化一个loading el: document.createElement(&#x27;div&#x27;), data: &#123; text: el.getAttribute(&#x27;loading-text&#x27;), // 通过loading-text属性获取loading的文字 fullscreen: !!binding.modifiers.fullscreen &#125; &#125;) el.instance = loading; // el.instance是个Vue实例 el.loading = loading.$el; // el.loading的DOM元素是loading.$el el.loadingStyle = &#123;&#125;; toggleLoading(el, binding); &#125;, update: (el, binding) =&gt; &#123; el.instance.setText(el.getAttribute(&#x27;loading-text&#x27;)) if (binding.oldValue !== binding.value) &#123; toggleLoading(el, binding) &#125; &#125;, unbind: (el, binding) =&gt; &#123; // 解绑 if (el.domInserted) &#123; if (binding.modifiers.fullscreen) &#123; document.body.removeChild(el.loading); &#125; else &#123; el.loading &amp;&amp; el.loading.parentNode &amp;&amp; el.loading.parentNode.removeChild(el.loading); &#125; &#125; &#125; &#125;) const toggleLoading = (el, binding) =&gt; &#123; // 用于控制Loading的出现与消失 if (binding.value) &#123; Vue.nextTick(() =&gt; &#123; if (binding.modifiers.fullscreen) &#123; // 如果是全屏 el.originalPosition = document.body.style.position; el.originalOverflow = document.body.style.overflow; insertDom(document.body, el, binding); // 插入dom &#125; else &#123; el.originalPosition = el.style.position; insertDom(el, el, binding); // 如果非全屏，插入元素自身 &#125; &#125;) &#125; else &#123; if (el.domVisible) &#123; el.instance.$on(&#x27;after-leave&#x27;, () =&gt; &#123; el.domVisible = false; if (binding.modifiers.fullscreen &amp;&amp; el.originalOverflow !== &#x27;hidden&#x27;) &#123; document.body.style.overflow = el.originalOverflow; &#125; if (binding.modifiers.fullscreen) &#123; document.body.style.position = el.originalPosition; &#125; else &#123; el.style.position = el.originalPosition; &#125; &#125;); el.instance.visible = false; &#125; &#125; &#125; const insertDom = (parent, el, binding) =&gt; &#123; // 插入dom的逻辑 if (!el.domVisible) &#123; Object.keys(el.loadingStyle).forEach(property =&gt; &#123; el.loading.style[property] = el.loadingStyle[property]; &#125;); if (el.originalPosition !== &#x27;absolute&#x27;) &#123; parent.style.position = &#x27;relative&#x27; &#125; if (binding.modifiers.fullscreen) &#123; parent.style.overflow = &#x27;hidden&#x27; &#125; el.domVisible = true; parent.appendChild(el.loading) // 插入的是el.loading而不是el本身 Vue.nextTick(() =&gt; &#123; el.instance.visible = true; &#125;); el.domInserted = true; &#125; &#125; &#125;&#125; 1&lt;div v-loading.fullscreen=&quot;loading&quot; loading-text=&quot;正在加载中&quot;&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue/"}]},{"title":"文字超出固定行数隐藏","slug":"超出固定行数隐藏","date":"2020-06-04T11:19:05.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2020/06/04/超出固定行数隐藏/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2020/06/04/%E8%B6%85%E5%87%BA%E5%9B%BA%E5%AE%9A%E8%A1%8C%E6%95%B0%E9%9A%90%E8%97%8F/","excerpt":"实现效果","text":"实现效果 css单行隐藏123456.text &#123; width: 300px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; css超出三行隐藏12345678.text &#123; width: 300px; overflow: hidden; display: -webkit-box; text-overflow: ellipsis; -webkit-box-orient: vertical; -webkit-line-clamp: 3;&#125; 判断是否有隐藏内容12let dom = document.querySelect(&#x27;.text&#x27;);return dom.scrollHeight &gt; dom.clientHeight; 展开按钮放在文字后面 ... 展开 在前端开发领域，我们经历了从jQuery为代表的面向过程编程向前端框架为代表的状态驱动模式的迁移。 当问到该选Vue还是React开发？，这样的问题会引起很大争议，但如果问到该选jQuery还是框架开发？，这样的问题就不会有太多争议。 收起 var expandBtn = document.querySelector('.expand-btn'); var rollupBtn = document.querySelector('.rollup-btn'); var textBox = document.querySelector('.text-box'); console.dir(textBox) expandBtn.addEventListener('click',function(){ this.style.display = 'none'; this.parentNode.style.maxHeight = ''; rollupBtn.style.display = ''; }) rollupBtn.addEventListener('click',function(){ this.style.display = 'none'; this.parentNode.style.maxHeight = '4.5em'; expandBtn.style.display = ''; }) css实现文字超出一行中间显示… .con { font-size: 14px; color: #666; width: 600px; margin: 50px auto; border-radius: 8px; padding: 15px; overflow: hidden; resize: horizontal; box-shadow: 20px 20px 60px #bebebe, -20px -20px 60px #ffffff; max-width: 800px; .wrap { position: relative; line-height: 2; height: 2em; padding: 0 10px; overflow: hidden; background: #fff; margin: 5px 0; } .wrap:nth-child(odd) { background: #f5f5f5; } .title { display: block; position: relative; background: inherit; text-align: justify; height: 2em; overflow: hidden; top: -4em; } .txt { display: block; max-height: 4em; } .title::before{ content: attr(title); width: 50%; float: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; direction: rtl; } } CSS 实现优惠券的技巧 CSS 实现优惠券的技巧 在前端开发领域，我们经历了从jQuery为代表的面向过程编程向前端框架为代表的状态驱动模式的迁移。 当问到该选Vue还是React开发？，这样的问题会引起很大争议，但如果问到该选jQuery还是框架开发？，这样的问题就不会有太多争议。 在前端开发领域，我们经历了从jQuery为代表的面向过程编程向前端框架为代表的状态驱动模式的迁移。 当问到该选Vue还是React开发？，这样的问题会引起很大争议，但如果问到该选jQuery还是框架开发？，这样的问题就不会有太多争议。 小程序怎么判断是否超出隐藏123456789101112const query = uni.createSelectorQuery().in(this);query.select(&quot;.status-box&quot;).boundingClientRect();query.exec((res)=&gt;&#123; res[0] = &#123; bottom: 271, left: 61, right: 362, top: 232, width: 301 height: 39 &#125;&#125;) 小程序中只能获取元素的实际高度，所以不能像浏览器端一样用滚动高度来判断有以下两个方式 拷贝一份元素，一个超出高度隐藏，另一个不隐藏，然后比较这两个的height 在末尾插入一个标签，然后判断容器的bottom比末尾元素的bottom要小","categories":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-28T15:25:23.000Z","updated":"2025-02-07T05:41:08.000Z","comments":true,"path":"2018/10/28/hello-world/","link":"","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/2018/10/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"分享","slug":"分享","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%88%86%E4%BA%AB/"},{"name":"优化","slug":"优化","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E4%BC%98%E5%8C%96/"},{"name":"快速上手","slug":"快速上手","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"name":"问题","slug":"问题","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E9%97%AE%E9%A2%98/"},{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/js/"},{"name":"工具","slug":"工具","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/python/"},{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/css/"},{"name":"html5","slug":"html5","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/html5/"},{"name":"linux","slug":"linux","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/linux/"},{"name":"regex","slug":"regex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/regex/"},{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/categories/vue/"}],"tags":[{"name":"react next.js","slug":"react-next-js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/react-next-js/"},{"name":"js","slug":"js","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js/"},{"name":"css","slug":"css","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/css/"},{"name":"vue","slug":"vue","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue/"},{"name":"react","slug":"react","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/react/"},{"name":"ssr","slug":"ssr","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/ssr/"},{"name":"正则","slug":"正则","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%AD%A3%E5%88%99/"},{"name":"前端","slug":"前端","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E5%89%8D%E7%AB%AF/"},{"name":"技巧","slug":"技巧","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%8A%80%E5%B7%A7/"},{"name":"svg","slug":"svg","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/svg/"},{"name":"nuxt","slug":"nuxt","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/nuxt/"},{"name":"调试","slug":"调试","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E8%B0%83%E8%AF%95/"},{"name":"Rollup","slug":"Rollup","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Rollup/"},{"name":"npm","slug":"npm","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/npm/"},{"name":"cli","slug":"cli","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/cli/"},{"name":"node","slug":"node","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/node/"},{"name":"vue3","slug":"vue3","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vue3/"},{"name":"git","slug":"git","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/git/"},{"name":"word2html","slug":"word2html","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/word2html/"},{"name":"gulp","slug":"gulp","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/gulp/"},{"name":"js动画","slug":"js动画","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/js%E5%8A%A8%E7%94%BB/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"},{"name":"reduce","slug":"reduce","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/reduce/"},{"name":"vuex","slug":"vuex","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/vuex/"},{"name":"flask","slug":"flask","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/flask/"},{"name":"Oauth","slug":"Oauth","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Oauth/"},{"name":"web","slug":"web","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/web/"},{"name":"Apache","slug":"Apache","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/Apache/"},{"name":"shell","slug":"shell","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/shell/"},{"name":"webpack","slug":"webpack","permalink":"https://chenshanshu.github.io/2020/06/15/hello-world/tags/webpack/"}]}